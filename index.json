{
  "api/Tomate.AccessControl.html": {
    "href": "api/Tomate.AccessControl.html",
    "title": "Struct AccessControl | Tomate",
    "keywords": "Struct AccessControl Namespace Tomate Assembly Tomate.dll Synchronization type that allows multiple concurrent shared access or one exclusive. Doesn't allow re-entrant calls, burn CPU cycle on wait, using SpinWait Costs 8 bytes of data. [PublicAPI] public struct AccessControl Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties LockedById Returns the Id of the current Process/Thread that own the lock public int LockedById { get; } Property Value int Remarks 0 is returned if the Access Control is not locked. The returned value is a xor combination of the Process Id and the threadId and should be used for information purpose only. SharedUsedCounter Returns the count of concurrent accesses. public int SharedUsedCounter { get; } Property Value int Methods Construct(MemorySegment<AccessControl>) Constructor an instance stored in the given memory segment public static ref AccessControl Construct(MemorySegment<AccessControl> segment) Parameters segment MemorySegment<AccessControl> The memory segment where the instance will be stored. Returns AccessControl The ref to the instance DemoteFromExclusiveAccess() Demote from exclusive to shared access public void DemoteFromExclusiveAccess() Remarks The calling process/thread must be in a valid exclusive state for this method to be called. EnterExclusiveAccess() Enter an exclusive access public void EnterExclusiveAccess() Remarks There can be only one process/thread being in the exclusive access state at a given time. If the AccessControl instance is being in shared mode or exclusive hold by another process/thread, the calling thread will wait until this call can be satisfied. Note that this method is not reentrant, if somewhere lower in the calling stack a method successfully entered an exclusive access, this call will wait indefinitely. EnterSharedAccess() Enter a shared access public void EnterSharedAccess() Remarks Shared access is typically used to allow concurrent readers, that is, many processes/threads can concurrently enter a shared access. If there is already an exclusive access being hold, the calling thread will wait until it can enter the shared access (which is the exclusive access to be released). While in shared access, if a process/thread attempts to enter an exclusive access calling EnterExclusiveAccess(),the calling thread will wait until there is no shared access at all to satisfy the request. You have the possibility to attempt transforming your shared access to an exclusive one by calling TryPromoteToExclusiveAccess(). If the calling thread is the only shared access the promotion will succeed and the thread will then become the exclusive owner. If there is at least another process/thread holding a shared access, the promotion attempt will fail. Be sure to call ExitSharedAccess() when you want to release the access. ExitExclusiveAccess() Release the exclusive access on the calling process/thread public void ExitExclusiveAccess() ExitSharedAccess() Exit a previously entered shared access public void ExitSharedAccess() Remarks A process/thread calling EnterSharedAccess() must call this method to release the shared access. Reset() Reset the usage of the instance to its default state. public void Reset() TryPromoteToExclusiveAccess() Attempt to promote a previously set shared access to exclusive public bool TryPromoteToExclusiveAccess() Returns bool true if the calling process/thread could switch to exclusive, false if the attempt failed (other processes/threads are also holding a shared access). Remarks This method will either switch from shared to exclusive or stay shared. Based on the outcome, you have to call the corresponding Exit method."
  },
  "api/Tomate.AlignmentExtensions.html": {
    "href": "api/Tomate.AlignmentExtensions.html",
    "title": "Class AlignmentExtensions | Tomate",
    "keywords": "Class AlignmentExtensions Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class AlignmentExtensions Inheritance object AlignmentExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Align(ref int, void*, int) public static void* Align(this ref int size, void* address, int alignment) Parameters size int address void* alignment int Returns void*"
  },
  "api/Tomate.BinarySearchComp-3.html": {
    "href": "api/Tomate.BinarySearchComp-3.html",
    "title": "Delegate BinarySearchComp<T1, T2, TResult> | Tomate",
    "keywords": "Delegate BinarySearchComp<T1, T2, TResult> Namespace Tomate Assembly Tomate.dll public delegate TResult BinarySearchComp<T1, T2, out TResult>(ref T1 arg1, ref T2 arg2) where T1 : unmanaged where T2 : unmanaged Parameters arg1 T1 arg2 T2 Returns TResult Type Parameters T1 T2 TResult Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T)"
  },
  "api/Tomate.BitMapHelpers.html": {
    "href": "api/Tomate.BitMapHelpers.html",
    "title": "Class BitMapHelpers | Tomate",
    "keywords": "Class BitMapHelpers Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class BitMapHelpers Inheritance object BitMapHelpers Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ClearBitConcurrent(Span<ulong>, int) public static bool ClearBitConcurrent(this Span<ulong> map, int index) Parameters map Span<ulong> index int Returns bool ClearBitsConcurrent(Span<ulong>, int, int) public static bool ClearBitsConcurrent(this Span<ulong> map, int index, int bitLength) Parameters map Span<ulong> index int bitLength int Returns bool FindFreeBitConcurrent(Span<ulong>) public static int FindFreeBitConcurrent(this Span<ulong> map) Parameters map Span<ulong> Returns int FindFreeBitsConcurrent(Span<ulong>, int) public static int FindFreeBitsConcurrent(this Span<ulong> map, int bitLength) Parameters map Span<ulong> bitLength int Returns int FindMaxBitSet(Span<ulong>) public static int FindMaxBitSet(this Span<ulong> map) Parameters map Span<ulong> Returns int FindSetBitConcurrent(Span<ulong>, ref int) Find the first bit set starting after the given index public static bool FindSetBitConcurrent(this Span<ulong> map, ref int index) Parameters map Span<ulong> The bitfield map index int The previous index of a bit found, must be -1 for the first call. Upon return, will contain the index of the found set bit or -1 if there was none (and the method will return false). Returns bool Returns true if the search was successful and a set bit was found, or false. IsBitSet(Span<ulong>, int) public static bool IsBitSet(this Span<ulong> map, int index) Parameters map Span<ulong> index int Returns bool SetBitConcurrent(Span<ulong>, int) Switch a bit from 0 to 1, concurrent friendly. public static bool SetBitConcurrent(this Span<ulong> map, int index) Parameters map Span<ulong> The bitmap storing the bits index int The index of the bit to set Returns bool true if the bit was successfully set, or false if another thread beat us to set this bit. Remarks For performance sake, there is no exception being thrown, but Debug.Assert fill fire for incorrect calls. SetBitsConcurrent(Span<ulong>, int, int) Switch several contiguous (all stored in the same ulong) bits from 0 to 1, concurrent friendly. public static bool SetBitsConcurrent(this Span<ulong> map, int index, int bitLength) Parameters map Span<ulong> The bitmap storing the bits index int The index of the first bit to set bitLength int The length, must be at least 1 and no more than 64. Returns bool true if the bits was successfully set, or false if another thread beat us to set at least one bit. Remarks As this is a concurrent friendly operation, only one ulong can be changed at a time, so the bits to change must be stored in the same ulong. For instance an index of 62 with a bitLength of 3 will generate a Debug Assert as it is addressing more than one ulong. For performance sake, there is no exception being thrown, but several Debug.Assert"
  },
  "api/Tomate.BlockOverrunException.html": {
    "href": "api/Tomate.BlockOverrunException.html",
    "title": "Class BlockOverrunException | Tomate",
    "keywords": "Class BlockOverrunException Namespace Tomate Assembly Tomate.dll [PublicAPI] public class BlockOverrunException : Exception, ISerializable Inheritance object Exception BlockOverrunException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors BlockOverrunException(MemoryBlock, string) public BlockOverrunException(MemoryBlock block, string msg) Parameters block MemoryBlock msg string Properties Block public MemoryBlock Block { get; } Property Value MemoryBlock"
  },
  "api/Tomate.BlockReferential.GenBlockHeader.html": {
    "href": "api/Tomate.BlockReferential.GenBlockHeader.html",
    "title": "Struct BlockReferential.GenBlockHeader | Tomate",
    "keywords": "Struct BlockReferential.GenBlockHeader Namespace Tomate Assembly Tomate.dll Each MemoryBlock allocated through a IMemoryManager based allocator must contain this header BEFORE the block's starting address. [PublicAPI] public struct BlockReferential.GenBlockHeader Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks MemoryBlock instances must be free-able without specifying the allocator that owns it and also supporting thread-safe lifetime related operations, so this header is the way to ensure all of this. More specifically, IBlockAllocator is the interface that takes care of freeing a MemoryBlock and the way to identify which particular instance of the Memory Manager is through the BlockIndex property. Be sure to check out DefaultMemoryManager to get and understand how things are working. Fields RefCounter The actual RefCounter of the MemoryBlock public int RefCounter Field Value int Remarks You should update this counter only through Increment(ref int) or Decrement(ref int) to ensure thread-safeness Properties BlockIndex public int BlockIndex { get; set; } Property Value int IsFree public bool IsFree { get; set; } Property Value bool IsFromMMF public bool IsFromMMF { get; set; } Property Value bool Methods Clear() public void Clear()"
  },
  "api/Tomate.BlockReferential.html": {
    "href": "api/Tomate.BlockReferential.html",
    "title": "Class BlockReferential | Tomate",
    "keywords": "Class BlockReferential Namespace Tomate Assembly Tomate.dll Static class that references all the IBlockAllocator to ensure a generic free of any allocated MemoryBlock. [PublicAPI] public static class BlockReferential Inheritance object BlockReferential Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields MaxReferencedBlockCount public const int MaxReferencedBlockCount = 16777216 Field Value int Methods Free(MemoryBlock) public static bool Free(MemoryBlock block) Parameters block MemoryBlock Returns bool GetMemoryManager(MemoryBlock) public static IMemoryManager GetMemoryManager(MemoryBlock block) Parameters block MemoryBlock Returns IMemoryManager Resize(ref MemoryBlock, int, bool) public static bool Resize(ref MemoryBlock block, int newLength, bool zeroExtra = false) Parameters block MemoryBlock newLength int zeroExtra bool Returns bool Resize<T>(ref MemoryBlock<T>, int, bool) public static bool Resize<T>(ref MemoryBlock<T> block, int newLength, bool zeroExtra = false) where T : unmanaged Parameters block MemoryBlock<T> newLength int zeroExtra bool Returns bool Type Parameters T UnregisterAllocator(int) public static void UnregisterAllocator(int index) Parameters index int"
  },
  "api/Tomate.BurnBabyBurn.html": {
    "href": "api/Tomate.BurnBabyBurn.html",
    "title": "Struct BurnBabyBurn | Tomate",
    "keywords": "Struct BurnBabyBurn Namespace Tomate Assembly Tomate.dll Put the calling thread in hold for a given time span [PublicAPI] public readonly struct BurnBabyBurn Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This type is mostly for testing/debugging purpose, the calling thread is spinning for a given time span, CPU is not consumed during this span, it relies on a particular assembly instruction that \"waits doing nothing\". The user typically create a while loop with Wait() being call as the while predicate. Constructors BurnBabyBurn(TimeSpan?) public BurnBabyBurn(TimeSpan? waitSpan) Parameters waitSpan TimeSpan? Methods Wait() Wait a bit public bool Wait() Returns bool true if the wait limit is not reached. false if the wait limit is reached and we should no longer call this method."
  },
  "api/Tomate.CapacityTooBigException.html": {
    "href": "api/Tomate.CapacityTooBigException.html",
    "title": "Class CapacityTooBigException | Tomate",
    "keywords": "Class CapacityTooBigException Namespace Tomate Assembly Tomate.dll [PublicAPI] public class CapacityTooBigException : Exception, ISerializable Inheritance object Exception CapacityTooBigException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors CapacityTooBigException(string) public CapacityTooBigException(string message) Parameters message string"
  },
  "api/Tomate.ConcurrentBitmapL3All.html": {
    "href": "api/Tomate.ConcurrentBitmapL3All.html",
    "title": "Class ConcurrentBitmapL3All | Tomate",
    "keywords": "Class ConcurrentBitmapL3All Namespace Tomate Assembly Tomate.dll Concurrent storage of a BitMap with three levels (two of aggregation) for efficient looking for empty bit. [PublicAPI] public class ConcurrentBitmapL3All Inheritance object ConcurrentBitmapL3All Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Thread Safety: safe, designed for concurrent use. Usage: Typically designed to implement an occupancy map. You have a Memory Block that can store x elements and you want to reserve/free these elements in a concurrent fashion. The occupancy map has one bit per element and when you want to allocate an element, you look for a free bit (with FindNextUnsetL0(ref int, ref long)) and reserve this bit with SetL0(int). You can also look for and set 64bits at a time (FindNextUnsetL1(ref int, ref long) and SetL1(int)). This class is designed for multiple thread concurrently looking for any available bit (corresponding entry set to 0) to set. A thread will call FindNextUnsetL0(ref int, ref long) to get the position of a bit actually free, and will call SetL0(int) to reserve it and set it to one. If another thread beats us and set this bit to one before us, then SetL0(int) will return false and we have to look for another bit. Implementation: As the BitMap may hold thousands of bits, looking for free ones, bit by bit, may take too much time as the occupancy rate increases. To alleviate this, we have two levels of aggregation that allow us to skips complete 64bits blocks (level 1) and compete 64^2 blocks (level 2) during our search. e.g. the first bit of the L1ALL map is set to 1 is all bit from [0-63] are set to 1. Finding an unset bit is concurrent friendly, many threads can execute such operation at the same time, but setting or clearing a bit has to be an exclusive operation (because of resize), but it's fast so if another thread has started such operation (TakeControl() is called), then we SpinWait until it can be our turn. Constructors ConcurrentBitmapL3All(int) Construct an instance public ConcurrentBitmapL3All(int bitCount) Parameters bitCount int Number of bits to host Properties Capacity public int Capacity { get; } Property Value int IsFull public bool IsFull { get; } Property Value bool TotalBitSet public int TotalBitSet { get; } Property Value int Methods ClearL0(int) public void ClearL0(int index) Parameters index int FindNextUnsetL0(ref int, ref long) public bool FindNextUnsetL0(ref int index, ref long mask) Parameters index int mask long Returns bool FindNextUnsetL1(ref int, ref long) public bool FindNextUnsetL1(ref int index, ref long mask) Parameters index int mask long Returns bool IsSet(int) public bool IsSet(int index) Parameters index int Returns bool Resize(int) public void Resize(int newBitCount) Parameters newBitCount int SetL0(int) public bool SetL0(int bitIndex) Parameters bitIndex int Returns bool SetL1(int) public bool SetL1(int index) Parameters index int Returns bool"
  },
  "api/Tomate.ConcurrentBitmapL4.html": {
    "href": "api/Tomate.ConcurrentBitmapL4.html",
    "title": "Struct ConcurrentBitmapL4 | Tomate",
    "keywords": "Struct ConcurrentBitmapL4 Namespace Tomate Assembly Tomate.dll This type allows to Allocate/Free bits in a bitmap in a concurrent friendly and scalable fashion. It is possible to allocate from 1 to 64 consecutive bits. [PublicAPI] public struct ConcurrentBitmapL4 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Thread Safety: safe, designed for concurrent use. Usage: Typically designed to implement an occupancy map, size can be in million range. The required size to store n-bits can be known by calling ComputeRequiredSize(int). You have a Memory Block that can store x elements and you want to reserve/free these elements in a concurrent fashion. The user will call AllocateBits(int) to allocate x consecutive elements and FreeBits(int, int) to free them. If allocation fails, the user can decide to wait/retry or give up, based on the concurrent usage of the instance. Implementation: There are four levels: - The L0 stores the bits, packed by 64-bits long. - The L1 stores for each L0 long the size of the biggest free segment the long store. (e.g. 0xFFF000FFFFFFF00F would be 12) - The L2 and L3 stores for each entry the max free segment of the 64 entries of the previous level. (e.g. 12 in L2[0] would mean that the biggest free segment found in the L1[0-63] would be 12. This allows us to skip 64, 4096, 262144 entries per test when looking for a free segment to allocate. L0/L1 are always used, but L2/L3 are activated based on the bitmap size. When you allocate 64bits, we are looking for an empty long in L0, as this type is concurrent friendly, setting the bits has to be an atomic operation so we can't allocate bits that overlap multiple longs. (e.g. 0xFFFFFFFF00000000 0x00000000FFFFFFFF, can't be used to allocate 64 bits). This is important to understand as allocating big sizes can lead to fragmentation and may not succeed because of it (fragmentation). Properties Capacity Capacity of the bitmap, in bits. public int Capacity { get; } Property Value int IsFull true if the map is full, false if there are free bits. public bool IsFull { get; } Property Value bool Remarks A non full map doesn't mean you will succeed to allocate, unless you are requested a bit size of 1. LookupCount public int LookupCount { get; } Property Value int LookupIterationCount public int LookupIterationCount { get; } Property Value int TotalBitSet Get the total count of bit set to one. public int TotalBitSet { get; } Property Value int Methods AllocateBits(int) public int AllocateBits(int requestedLength) Parameters requestedLength int Returns int ComputeMaxFreeSegment(ulong) public static int ComputeMaxFreeSegment(ulong n) Parameters n ulong Returns int ComputeRequiredSize(int) Compute the size in byte, required to store a bitmap of the given size. public static int ComputeRequiredSize(int bitCount) Parameters bitCount int The bit count to compute the size from Returns int The size in byte. Remarks L0/L1 levels are always used, L2/L3 will be activated based on the requested size. Create(int, MemorySegment) public static ConcurrentBitmapL4 Create(int bitCount, MemorySegment storage) Parameters bitCount int storage MemorySegment Returns ConcurrentBitmapL4 FreeBits(int, int) public void FreeBits(int index, int requestedLength) Parameters index int requestedLength int Map(int, MemorySegment) public static ConcurrentBitmapL4 Map(int bitCount, MemorySegment storage) Parameters bitCount int storage MemorySegment Returns ConcurrentBitmapL4 SanityCheck(out string) public bool SanityCheck(out string error) Parameters error string Returns bool"
  },
  "api/Tomate.DefaultMemoryManager.DebugMemoryInit.html": {
    "href": "api/Tomate.DefaultMemoryManager.DebugMemoryInit.html",
    "title": "Enum DefaultMemoryManager.DebugMemoryInit | Tomate",
    "keywords": "Enum DefaultMemoryManager.DebugMemoryInit Namespace Tomate Assembly Tomate.dll Debugging feature to initialize the MemoryBlock's content upon allocation (available in DEBUGALlOC only) public enum DefaultMemoryManager.DebugMemoryInit Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Fields None = 0 Pattern = 2 Zero = 1"
  },
  "api/Tomate.DefaultMemoryManager.html": {
    "href": "api/Tomate.DefaultMemoryManager.html",
    "title": "Class DefaultMemoryManager | Tomate",
    "keywords": "Class DefaultMemoryManager Namespace Tomate Assembly Tomate.dll General purpose Memory Manager [PublicAPI] public class DefaultMemoryManager : IDisposable, IMemoryManager, IPageAllocator Inheritance object DefaultMemoryManager Implements IDisposable IMemoryManager IPageAllocator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Purpose Thread-safe, general purpose allocation of memory block of any size (up to almost 2Gb). This implementation was not meant to be very fast and memory efficient, I've just tried to find a good balance between speed, memory overhead and complexity. I do think though it's quite fast, should behave correctly regarding contention and is definitely more than acceptable regarding fragmentation. Design and implementation Being thread-safe impose a lot of special care to behave correctly regarding perf and contention. The MemoryManager has several sub-types : DefaultMemoryManager.NativeBlockInfo which is responsible of making OS level allocation, a given Native Block will then serve memory allocation requests for many DefaultMemoryManager.SmallBlockAllocator and or DefaultMemoryManager.LargeBlockAllocator instances. DefaultMemoryManager.BlockAllocatorSequence, there are many instances of this type, the number is determined during the manager construction and depending on the CPU core number. Then each Thread is assigned a given instance (we assign them in round-robin fashion). The Block Sequence contains two chained lists, one for DefaultMemoryManager.SmallBlockAllocator and the other for DefaultMemoryManager.LargeBlockAllocator. DefaultMemoryManager.SmallBlockAllocator is responsible of making small ( >= 65526 bytes) MemorySegment allocations. It uses a slab of a given DefaultMemoryManager.NativeBlockInfo instance. Instances of DefaultMemoryManager.SmallBlockAllocator are operating concurrently: two different threads using different instance won't compete for Allocation/Free. DefaultMemoryManager.LargeBlockAllocator take care of Allocations greater than 65526 bytes and will hold a Native Memory block of at least 64 MiB or sized with the next power of 2 of the allocation that triggered it. Allocated MemorySegment are guaranteed to be 16 bytes address-aligned. MemorySegment that was allocated by DefaultMemoryManager.SmallBlockAllocator have a 14 bytes header that precedes each instance, for DefaultMemoryManager.LargeBlockAllocator the header is 20 bytes. These are the only overhead that is dependent of each Segment allocation. DefaultMemoryManager.SmallBlockAllocator and DefaultMemoryManager.LargeBlockAllocator have defragmentation routines that are called when free segment fragmentation is too high to merge adjacent free segments. DefaultMemoryManager.BlockAllocatorSequence will release empty Blocks (Small and Large), they will be added to a dedicated pool on the Memory Manager and reassigned when possible to other Block Sequence that are requested memory. Which means the allocated Native Memory is never released, but reused. If you want to release is, the only way is to call Clear(). Constructors DefaultMemoryManager(int, int) public DefaultMemoryManager(int pageSize = 1048576, int maxPageCount = 1024) Parameters pageSize int maxPageCount int Fields GlobalInstance Access to the global instance of the Memory Manager public static readonly DefaultMemoryManager GlobalInstance Field Value DefaultMemoryManager Remarks Most of the time you will want to rely on this instance. Note that you can't dispose it nor Clear() it as it is a shared instance. The memory will be freed when the process will exit. If you need control over the lifetime, create and use your own instance. MaxMemorySegmentSize public static readonly int MaxMemorySegmentSize Field Value int MinSegmentSize public static readonly int MinSegmentSize Field Value int PageAllocatorMaxPageCount public static readonly int PageAllocatorMaxPageCount Field Value int PageAllocatorPageSize public static readonly int PageAllocatorPageSize Field Value int StoreMaxEntryCount public static readonly int StoreMaxEntryCount Field Value int Properties BaseAddress Return the base address of the linear memory block that old all the pages. public byte* BaseAddress { get; } Property Value byte* IsDisposed Check if the instance is disposed or not. public bool IsDisposed { get; } Property Value bool MaxAllocationLength public int MaxAllocationLength { get; } Property Value int MemoryBlockContentCleanup This property only works in DEBUGALLOC mode, it is primarily used to change the content of a memory block being freed, for debugging/troubleshooting purposes. public DefaultMemoryManager.DebugMemoryInit MemoryBlockContentCleanup { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization This property only works in DEBUGALLOC mode, it is primarily used to initialize the content of newly allocated block, for debugging/troubleshooting purposes. public DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryManagerId public int MemoryManagerId { get; } Property Value int PageAllocatorId public int PageAllocatorId { get; } Property Value int PageSize Return the size of one given page public int PageSize { get; } Property Value int Store public ref UnmanagedDataStore Store { get; } Property Value UnmanagedDataStore Methods Allocate(int) Allocate a Memory Block public MemoryBlock Allocate(int length) Parameters length int Length of the block to allocate. Returns MemoryBlock The block or an exception will be fired if we couldn't allocate one. Remarks The block's address will always be aligned on at least 16 bytes. The block's address is fixed. Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. AllocatePages(int) Allocate one or many consecutive pages public MemorySegment AllocatePages(int length) Parameters length int Must be 1 to 64. Returns MemorySegment The returned memory segment will be PageSize*length. Return default if the allocation failed. Allocate<T>(int) Allocate a Memory Block public MemoryBlock<T> Allocate<T>(int length) where T : unmanaged Parameters length int Length (in {T}) of the segment to allocate. Returns MemoryBlock<T> The segment or an exception will be fired if we couldn't allocate one. Type Parameters T The type of each item of the segment assigned to the block. Remarks The segment's address will always be aligned on 16 bytes, its size will also be padded on 16 bytes. The segment's address is fixed. Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. Clear() Release all the allocated segments, free the memory allocated through .net. public void Clear() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Free(MemoryBlock) Free a previously allocated block public bool Free(MemoryBlock block) Parameters block MemoryBlock The memory block to free Returns bool true if the block was successfully released, false otherwise. Exceptions ObjectDisposedException Can't free if the instance is disposed, all blocks have been released anyway. FreePages(MemorySegment) Free the pages previously allocated corresponding to the given segment. public bool FreePages(MemorySegment pages) Parameters pages MemorySegment The memory segment spanning all the pages to free. Returns bool true if the operation succeeded, false otherwise. Free<T>(MemoryBlock<T>) public bool Free<T>(MemoryBlock<T> block) where T : unmanaged Parameters block MemoryBlock<T> Returns bool Type Parameters T FromBlockId(int) Convert a BlockId to its corresponding MemorySegment public MemorySegment FromBlockId(int blockId) Parameters blockId int The BlockId previously retrieved with ToBlockId(MemorySegment). Returns MemorySegment The corresponding memory segment or default if it failed. ToBlockId(MemorySegment) Convert the given segment's start address to the corresponding BlockId public int ToBlockId(MemorySegment segment) Parameters segment MemorySegment The segment to get the BlockId from Returns int The BlockId, an integer that contains the index of the block and its length encoded as two shorts."
  },
  "api/Tomate.DisposeExtensions.html": {
    "href": "api/Tomate.DisposeExtensions.html",
    "title": "Class DisposeExtensions | Tomate",
    "keywords": "Class DisposeExtensions Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class DisposeExtensions Inheritance object DisposeExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DisposeAndNull<T>(object, ref T) public static void DisposeAndNull<T>(this object owner, ref T obj) where T : class, IDisposable Parameters owner object obj T Type Parameters T"
  },
  "api/Tomate.ExclusiveAccessControl.html": {
    "href": "api/Tomate.ExclusiveAccessControl.html",
    "title": "Struct ExclusiveAccessControl | Tomate",
    "keywords": "Struct ExclusiveAccessControl Namespace Tomate Assembly Tomate.dll Simple access control supporting a single process and only exclusive access [PublicAPI] public struct ExclusiveAccessControl Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks The size of this struct is only 4 bytes. Constructors ExclusiveAccessControl() Default constructor public ExclusiveAccessControl() Methods ReleaseControl() Release a previously gained exclusive access by the calling thread public bool ReleaseControl() Returns bool true if the calling thread had an exclusive access that is now released by calling this method. false if the calling thread was not having an exclusive access. TakeControl(TimeSpan?) Try to gain exclusive access for the calling thread, trying for a given time span if needed. public bool TakeControl(TimeSpan? wait = null) Parameters wait TimeSpan? The time span where the exclusive attempt should be repeatedly made. If null is passed, this method will wait indefinitely until it gain the exclusive access. Doing this could lead to endless waiting if your code is not dead stable. Returns bool true if the exclusive control was successfully made, false if it couldn't be made for the given time span. Examples A safe approach would be doing this var hold = c.TakeControl(TimeSpan.FromMilliseconds(10)); try { if (hold) { // // your code here // } } finally { if (hold) { c.ReleaseControl(); } } Remarks If exclusive control was successfully taken, you must call ReleaseControl() to release it when you're done. Failing to do so would cause other threads to possibly endlessly wait and/or not being able to mutate the resource controlled by this instance. TryTakeControl() Try to gain exclusive access for the calling thread public bool TryTakeControl() Returns bool true if the thread could take the exclusive control, false if the attempt failed because another thread currently holds the exclusive access. Remarks This method won't wait, it will try to get the exclusive access and take it if possible or return a failure if it couldn't. If you are willing to wait to gain exclusive access, call TakeControl(TimeSpan?) instead."
  },
  "api/Tomate.IMemoryManager.html": {
    "href": "api/Tomate.IMemoryManager.html",
    "title": "Interface IMemoryManager | Tomate",
    "keywords": "Interface IMemoryManager Namespace Tomate Assembly Tomate.dll About IMemoryManager is the interface used to implement a custom Memory Manager. The manager duty is to allocated, resize, free block of memory. 🍅 implements many memory manager, you can find more about it here. Collections and other types that rely on memory allocation will ask for a given instance implementing this interface. unmanaged struct limitation When we do GC-free programming, we want to stay away from class based instances, but we still have to deal with some of them sometimes. In this case, types implementing IMemoryManager are meant to be class based, but at some point, if you want to store an instance of a given Memory Manager in say, your UnmanagedList<T> instance, you can't declare such field if you want your struct to be considered as unmanaged. For such reason we have methods in this interface to Register and instance, which return an ID that can be stored anywhere. Then you can access a given Memory Manager from its ID using GetMemoryManager(). Definition [PublicAPI] public interface IMemoryManager Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties IsDisposed Check if the instance is disposed or not. bool IsDisposed { get; } Property Value bool MaxAllocationLength int MaxAllocationLength { get; } Property Value int MemoryBlockContentCleanup This property only works in DEBUGALLOC mode, it is primarily used to change the content of a memory block being freed, for debugging/troubleshooting purposes. DefaultMemoryManager.DebugMemoryInit MemoryBlockContentCleanup { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization This property only works in DEBUGALLOC mode, it is primarily used to initialize the content of newly allocated block, for debugging/troubleshooting purposes. DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryManagerId int MemoryManagerId { get; } Property Value int Store ref UnmanagedDataStore Store { get; } Property Value UnmanagedDataStore Methods Allocate(int) Allocate a Memory Block MemoryBlock Allocate(int length) Parameters length int Length of the block to allocate. Returns MemoryBlock The block or an exception will be fired if we couldn't allocate one. Remarks The block's address will always be aligned on at least 16 bytes. The block's address is fixed. Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. Allocate<T>(int) Allocate a Memory Block MemoryBlock<T> Allocate<T>(int length) where T : unmanaged Parameters length int Length (in {T}) of the segment to allocate. Returns MemoryBlock<T> The segment or an exception will be fired if we couldn't allocate one. Type Parameters T The type of each item of the segment assigned to the block. Remarks The segment's address will always be aligned on 16 bytes, its size will also be padded on 16 bytes. The segment's address is fixed. Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. Clear() Release all the allocated segments, free the memory allocated through .net. void Clear() Free(MemoryBlock) Free a previously allocated block bool Free(MemoryBlock block) Parameters block MemoryBlock The memory block to free Returns bool true if the block was successfully released, false otherwise. Exceptions ObjectDisposedException Can't free if the instance is disposed, all blocks have been released anyway. Free<T>(MemoryBlock<T>) bool Free<T>(MemoryBlock<T> block) where T : unmanaged Parameters block MemoryBlock<T> Returns bool Type Parameters T GetMemoryManager(int) public static IMemoryManager GetMemoryManager(int id) Parameters id int Returns IMemoryManager RegisterMemoryManager(IMemoryManager) public static int RegisterMemoryManager(IMemoryManager memoryManager) Parameters memoryManager IMemoryManager Returns int Resize(ref MemoryBlock, int, bool) bool Resize(ref MemoryBlock memoryBlock, int newLength, bool zeroExtra = false) Parameters memoryBlock MemoryBlock newLength int zeroExtra bool Returns bool Resize<T>(ref MemoryBlock<T>, int, bool) bool Resize<T>(ref MemoryBlock<T> memoryBlock, int newLength, bool zeroExtra = false) where T : unmanaged Parameters memoryBlock MemoryBlock<T> newLength int zeroExtra bool Returns bool Type Parameters T UnregisterMemoryManager(int) public static bool UnregisterMemoryManager(int memoryManagerId) Parameters memoryManagerId int Returns bool"
  },
  "api/Tomate.IPageAllocator.html": {
    "href": "api/Tomate.IPageAllocator.html",
    "title": "Interface IPageAllocator | Tomate",
    "keywords": "Interface IPageAllocator Namespace Tomate Assembly Tomate.dll About The IPageAllocator interface allows one to implement a very simple allocator which allocates fixed-size pages. It is possible to allocate consecutive pages, the valid range is [1-64]. 🍅 implements a simple page allocator with the PageAllocator type. Definition [PublicAPI] public interface IPageAllocator Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties BaseAddress Return the base address of the linear memory block that old all the pages. byte* BaseAddress { get; } Property Value byte* PageAllocatorId int PageAllocatorId { get; } Property Value int PageSize Return the size of one given page int PageSize { get; } Property Value int Methods AllocatePages(int) Allocate one or many consecutive pages MemorySegment AllocatePages(int length) Parameters length int Must be 1 to 64. Returns MemorySegment The returned memory segment will be PageSize*length. Return default if the allocation failed. FreePages(MemorySegment) Free the pages previously allocated corresponding to the given segment. bool FreePages(MemorySegment pages) Parameters pages MemorySegment The memory segment spanning all the pages to free. Returns bool true if the operation succeeded, false otherwise. FromBlockId(int) Convert a BlockId to its corresponding MemorySegment MemorySegment FromBlockId(int blockId) Parameters blockId int The BlockId previously retrieved with ToBlockId(MemorySegment). Returns MemorySegment The corresponding memory segment or default if it failed. GetPageAllocator(int) public static IPageAllocator GetPageAllocator(int id) Parameters id int Returns IPageAllocator RegisterPageAllocator(IPageAllocator) public static int RegisterPageAllocator(IPageAllocator pageAllocator) Parameters pageAllocator IPageAllocator Returns int ToBlockId(MemorySegment) Convert the given segment's start address to the corresponding BlockId int ToBlockId(MemorySegment segment) Parameters segment MemorySegment The segment to get the BlockId from Returns int The BlockId, an integer that contains the index of the block and its length encoded as two shorts. UnregisterPageAllocator(int) public static bool UnregisterPageAllocator(int pageAllocatorId) Parameters pageAllocatorId int Returns bool"
  },
  "api/Tomate.IProcessProvider.html": {
    "href": "api/Tomate.IProcessProvider.html",
    "title": "Interface IProcessProvider | Tomate",
    "keywords": "Interface IProcessProvider Namespace Tomate Assembly Tomate.dll [PublicAPI] public interface IProcessProvider Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties CurrentProcessId int CurrentProcessId { get; } Property Value int Singleton public static IProcessProvider Singleton { get; set; } Property Value IProcessProvider Methods IsProcessAlive(int) bool IsProcessAlive(int processId) Parameters processId int Returns bool"
  },
  "api/Tomate.IRefCounted.html": {
    "href": "api/Tomate.IRefCounted.html",
    "title": "Interface IRefCounted | Tomate",
    "keywords": "Interface IRefCounted Namespace Tomate Assembly Tomate.dll [PublicAPI] public interface IRefCounted : IDisposable Inherited Members IDisposable.Dispose() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties IsDisposed bool IsDisposed { get; } Property Value bool RefCounter int RefCounter { get; } Property Value int Methods AddRef() int AddRef() Returns int"
  },
  "api/Tomate.IUnmanagedCollection.html": {
    "href": "api/Tomate.IUnmanagedCollection.html",
    "title": "Interface IUnmanagedCollection | Tomate",
    "keywords": "Interface IUnmanagedCollection Namespace Tomate Assembly Tomate.dll Facade for an unmanaged based instance public interface IUnmanagedCollection : IRefCounted, IDisposable Inherited Members IRefCounted.IsDisposed IRefCounted.RefCounter IRefCounted.AddRef() IDisposable.Dispose() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Each struct implementing this interface must follow a very specific constraint: The data layout must be one field of type MemoryBlock and that's it! Which means each instance of a given type must be allocated through a IMemoryManager. Properties MemoryBlock MemoryBlock MemoryBlock { get; } Property Value MemoryBlock MemoryManager IMemoryManager MemoryManager { get; } Property Value IMemoryManager Methods RefreshFromMMF(MemoryBlock) void RefreshFromMMF(MemoryBlock newData) Parameters newData MemoryBlock"
  },
  "api/Tomate.InvalidAllocationSizeException.html": {
    "href": "api/Tomate.InvalidAllocationSizeException.html",
    "title": "Class InvalidAllocationSizeException | Tomate",
    "keywords": "Class InvalidAllocationSizeException Namespace Tomate Assembly Tomate.dll public class InvalidAllocationSizeException : Exception, ISerializable Inheritance object Exception InvalidAllocationSizeException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors InvalidAllocationSizeException(string) public InvalidAllocationSizeException(string message) Parameters message string"
  },
  "api/Tomate.InvalidHandleException.html": {
    "href": "api/Tomate.InvalidHandleException.html",
    "title": "Class InvalidHandleException | Tomate",
    "keywords": "Class InvalidHandleException Namespace Tomate Assembly Tomate.dll [PublicAPI] public class InvalidHandleException : Exception, ISerializable Inheritance object Exception InvalidHandleException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors InvalidHandleException() public InvalidHandleException() InvalidHandleException(string) public InvalidHandleException(string message) Parameters message string"
  },
  "api/Tomate.InvalidObjectException.html": {
    "href": "api/Tomate.InvalidObjectException.html",
    "title": "Class InvalidObjectException | Tomate",
    "keywords": "Class InvalidObjectException Namespace Tomate Assembly Tomate.dll [PublicAPI] public class InvalidObjectException : Exception, ISerializable Inheritance object Exception InvalidObjectException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors InvalidObjectException() public InvalidObjectException() InvalidObjectException(string) public InvalidObjectException(string message) Parameters message string"
  },
  "api/Tomate.ItemMaxCapacityReachedException.html": {
    "href": "api/Tomate.ItemMaxCapacityReachedException.html",
    "title": "Class ItemMaxCapacityReachedException | Tomate",
    "keywords": "Class ItemMaxCapacityReachedException Namespace Tomate Assembly Tomate.dll [PublicAPI] public class ItemMaxCapacityReachedException : Exception, ISerializable Inheritance object Exception ItemMaxCapacityReachedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors ItemMaxCapacityReachedException(string) public ItemMaxCapacityReachedException(string message) Parameters message string"
  },
  "api/Tomate.ItemSetTooBigException.html": {
    "href": "api/Tomate.ItemSetTooBigException.html",
    "title": "Class ItemSetTooBigException | Tomate",
    "keywords": "Class ItemSetTooBigException Namespace Tomate Assembly Tomate.dll [PublicAPI] public class ItemSetTooBigException : Exception, ISerializable Inheritance object Exception ItemSetTooBigException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors ItemSetTooBigException(string) public ItemSetTooBigException(string message) Parameters message string"
  },
  "api/Tomate.LogicalMemorySegment.html": {
    "href": "api/Tomate.LogicalMemorySegment.html",
    "title": "Struct LogicalMemorySegment | Tomate",
    "keywords": "Struct LogicalMemorySegment Namespace Tomate Assembly Tomate.dll Stores the location and size of a logical memory segment [PublicAPI] public readonly struct LogicalMemorySegment Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Define a memory segment inside another one using an offset and a size. This structure is the most compact one, ToSpan<T>(void*) performance is a little bit slower than MemorySegment's implementation. Constructors LogicalMemorySegment(int, int) public LogicalMemorySegment(int offset, int size) Parameters offset int size int Fields Offset public readonly int Offset Field Value int Size public readonly int Size Field Value int Methods ToSpan<T>(void*) public Span<T> ToSpan<T>(void* baseAddr) where T : unmanaged Parameters baseAddr void* Returns Span<T> Type Parameters T"
  },
  "api/Tomate.MappedAppendCollection-1.html": {
    "href": "api/Tomate.MappedAppendCollection-1.html",
    "title": "Struct MappedAppendCollection<T> | Tomate",
    "keywords": "Struct MappedAppendCollection<T> Namespace Tomate Assembly Tomate.dll Append-only collection on a Page Allocator [PublicAPI] public struct MappedAppendCollection<T> : IDisposable where T : unmanaged Type Parameters T Type of each item of the collection Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Usage: This is a pretty simple type: the user creates an instance by passing an allocator and a capacity (the maximum number of pages that will be allocated). Each page can stores up to x items (x = PageSize / sizeof(T)). The user then allocates a set of x items by calling Reserve(int, out int) an ID is returned and used for access to the MemorySegment addressing these items later by calling Get(int, int). Allocated items can't be freed: it's an append-only collection. Implementation: The collection stores a Page Directory inside the first page, this directory contains for each page its offset from the base address of the allocator. The ID returned by Reserve(int, out int) is a linear offset into the collection and we use the Page Directory to determine in which page is stored the given set of items. You can't allocate a set of item that exceed the number of items a given page can hold because each set is a contiguous space of data. If when calling Reserve(int, out int) the current page can't hold the requested number of items, the remaining space in this page is simply wasted and another one is allocated. Which means you could end up with a big fragmentation and poor usage ratio if you always allocate sets of items that are bigger than half of a PageSize, so choose the Page Size of the allocator accordingly ! This type can address a very big space of data, way above 4GiB. The limit is PageSize * Capacity * sizeof(T) Properties AllocatedPageCount public int AllocatedPageCount { get; } Property Value int AllocationStats public (long totalAllocatedByte, float efficiency) AllocationStats { get; } Property Value (long totalAllocatedByte, float efficiency) Capacity public int Capacity { get; } Property Value int MaxItemCountPerPage public int MaxItemCountPerPage { get; } Property Value int PageSize public int PageSize { get; } Property Value int RootPageId public readonly int RootPageId { get; } Property Value int Methods Create(IPageAllocator, int) public static MappedAppendCollection<T> Create(IPageAllocator allocator, int pageCapacity) Parameters allocator IPageAllocator pageCapacity int Returns MappedAppendCollection<T> Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Get(int, int) public MemorySegment<T> Get(int id, int length) Parameters id int length int Returns MemorySegment<T> Get<TN>(int) public ref TN Get<TN>(int nodeId) where TN : unmanaged Parameters nodeId int Returns TN Type Parameters TN Map(IPageAllocator, int) public static MappedAppendCollection<T> Map(IPageAllocator allocator, int rootPageId) Parameters allocator IPageAllocator rootPageId int Returns MappedAppendCollection<T> Reserve(int, out int) public MemorySegment<T> Reserve(int length, out int id) Parameters length int id int Returns MemorySegment<T> Reserve<TN>(out int) public ref TN Reserve<TN>(out int id) where TN : unmanaged Parameters id int Returns TN Type Parameters TN"
  },
  "api/Tomate.MappedBlockingSimpleDictionary-2.Enumerator.html": {
    "href": "api/Tomate.MappedBlockingSimpleDictionary-2.Enumerator.html",
    "title": "Struct MappedBlockingSimpleDictionary<TKey, TValue>.Enumerator | Tomate",
    "keywords": "Struct MappedBlockingSimpleDictionary<TKey, TValue>.Enumerator Namespace Tomate Assembly Tomate.dll Enumerates the elements of the dictionary. public struct MappedBlockingSimpleDictionary<TKey, TValue>.Enumerator : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties Current Gets the element at the current position of the enumerator. public MappedBlockingSimpleDictionary<TKey, TValue>.KeyValuePair Current { get; } Property Value MappedBlockingSimpleDictionary<TKey, TValue>.KeyValuePair Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() MoveNext() Advances the enumerator to the next element of the segment. public bool MoveNext() Returns bool"
  },
  "api/Tomate.MappedBlockingSimpleDictionary-2.KeyValuePair.html": {
    "href": "api/Tomate.MappedBlockingSimpleDictionary-2.KeyValuePair.html",
    "title": "Struct MappedBlockingSimpleDictionary<TKey, TValue>.KeyValuePair | Tomate",
    "keywords": "Struct MappedBlockingSimpleDictionary<TKey, TValue>.KeyValuePair Namespace Tomate Assembly Tomate.dll Store an item public struct MappedBlockingSimpleDictionary<TKey, TValue>.KeyValuePair Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors KeyValuePair(TKey, TValue) public KeyValuePair(TKey k, TValue v) Parameters k TKey v TValue Fields Key Key, can't be default(TKey). public TKey Key Field Value TKey Value Value associated to the key public TValue Value Field Value TValue"
  },
  "api/Tomate.MappedBlockingSimpleDictionary-2.html": {
    "href": "api/Tomate.MappedBlockingSimpleDictionary-2.html",
    "title": "Struct MappedBlockingSimpleDictionary<TKey, TValue> | Tomate",
    "keywords": "Struct MappedBlockingSimpleDictionary<TKey, TValue> Namespace Tomate Assembly Tomate.dll Fixed size, not efficient dictionary, with concurrent operations made through a lock [PublicAPI] public struct MappedBlockingSimpleDictionary<TKey, TValue> where TKey : unmanaged where TValue : unmanaged Type Parameters TKey TValue Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Designed to be simple, accesses are O(n), a key of value default(TKey) is not permitted as it's used to detect free entries. Read-only access operations are made through a shared lock, read-write through an exclusive one. There can be multiple concurrent RO operations, but any RW operation will be exclusive and block any other RO/RW operations. You can enumerate the dictionary content, but only to evaluate it. Any call to ro/rw operations would lead to a deadlock. Properties Capacity Number of KVP items the dictionary can hold public int Capacity { get; } Property Value int Count Actual count of items stored public int Count { get; } Property Value int this[TKey] Get or add/update the value associated with the given key public TValue this[TKey key] { get; set; } Parameters key TKey The key Property Value TValue The value associated with the key or default(TValue) if the key doesn't exist in the dictionary Remarks The getter does a TryGet(TKey, out TValue). The setter does a AddOrUpdate(TKey, TValue). Methods AddOrUpdate(TKey, TValue) Add the given key/value pair or update the value of the given key if it's already present in the dictionary public bool AddOrUpdate(TKey key, TValue value) Parameters key TKey The key value TValue The value Returns bool true if the operation succeeded, false if the key/value pair couldn't be added because the dictionary is full Clear() Clear the whole dictionary public void Clear() ComputeItemCapacity(int) Compute the item capacity from a given storage size public static int ComputeItemCapacity(int storageSize) Parameters storageSize int The storage size to compute the capacity from Returns int The item capacity ComputeStorageSize(int) Compute the memory size taken to store a given amount of items public static int ComputeStorageSize(int itemCount) Parameters itemCount int Item count to compute the storage size from Returns int The required size, a MemorySegment of this size would store the request amount of items Contains(TKey) Check if there's a key of the given value stored in the dictionary public bool Contains(TKey key) Parameters key TKey The key Returns bool true if the dictionary stores the requested key, false otherwise. Remarks This operation relies on a shared access. Create(MemorySegment) public static MappedBlockingSimpleDictionary<TKey, TValue> Create(MemorySegment segment) Parameters segment MemorySegment Returns MappedBlockingSimpleDictionary<TKey, TValue> GetEnumerator() Gets an enumerator for this dictionary public MappedBlockingSimpleDictionary<TKey, TValue>.Enumerator GetEnumerator() Returns MappedBlockingSimpleDictionary<TKey, TValue>.Enumerator Remarks A shared lock will be created before enumeration and released at the end. The enumeration is not meant to change the content of the dictionary. Don't call any operation on the dictionary that leads to a shared/exclusive access, it would lead to a dead-lock as locks are not re-entrant on this type. GetOrAdd(TKey, Func<TKey, TValue>, out bool, out bool) Get a value associated with the given key or add a new key/value pair. public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory, out bool added, out bool success) Parameters key TKey The key valueFactory Func<TKey, TValue> A factory that will be called to generated the value if the key was not present in the dictionary added bool true if the key/value pair was added, false if the key/value pair already exists in the dictionary success bool true if the operation succeeded, falseif the dictionary is full and the key/value pair couldn't be added Returns TValue The value associated with the given key Remarks This operation relies on an exclusive access. Map(MemorySegment) public static MappedBlockingSimpleDictionary<TKey, TValue> Map(MemorySegment segment) Parameters segment MemorySegment Returns MappedBlockingSimpleDictionary<TKey, TValue> ToArray() Project all the items of the dictionary to a KeyValuePair array public MappedBlockingSimpleDictionary<TKey, TValue>.KeyValuePair[] ToArray() Returns KeyValuePair[] The array containing the items Remarks This operation relies on a shared access. You would typically use this method over content enumeration if you want to hold the shared lock the shortest time possible. TryAdd(TKey, TValue) Try to add a key/value to the dictionary public bool TryAdd(TKey key, TValue value) Parameters key TKey The key, can't be default(TKey). value TValue The value. Returns bool true if the dictionary added the requested key/value, false if there were already a key with this value. Remarks This operation relies on an exclusive access. TryGet(TKey, out TValue) Try to get the value from a given key public bool TryGet(TKey key, out TValue value) Parameters key TKey The key to use value TValue The value corresponding Returns bool true if the dictionary stores the requested key, false otherwise. Remarks This operation relies on a shared access. TryRemove(TKey, out TValue) Remove a key/value from the dictionary public bool TryRemove(TKey key, out TValue value) Parameters key TKey The key. value TValue The value, is default if the call is unsuccessful. Returns bool true if the key/value were removed, false if there were no key of the given value. Remarks This operation relies on an exclusive access. TryUpdateValue(TKey, TValue) Change the value associated with a given key public bool TryUpdateValue(TKey key, TValue newValue) Parameters key TKey The key. newValue TValue The new value to set Returns bool true if the value has been set, false if there were no key of the given value. Remarks This operation relies on an exclusive access."
  },
  "api/Tomate.MappedConcurrentChunkBasedCircularBuffer.html": {
    "href": "api/Tomate.MappedConcurrentChunkBasedCircularBuffer.html",
    "title": "Struct MappedConcurrentChunkBasedCircularBuffer | Tomate",
    "keywords": "Struct MappedConcurrentChunkBasedCircularBuffer Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MappedConcurrentChunkBasedCircularBuffer Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties Occupancy public double Occupancy { get; } Property Value double TotalWaitedCount public readonly int TotalWaitedCount { get; } Property Value int Methods ConcurrentReserve(short, short, bool) public MemorySegment ConcurrentReserve(short chunkId, short size, bool waitIfFull) Parameters chunkId short size short waitIfFull bool Returns MemorySegment ConcurrentReserveNext() public void ConcurrentReserveNext() ConcurrentReserve<T>(short, bool) public MemorySegment<T> ConcurrentReserve<T>(short chunkid, bool waitIfFull) where T : unmanaged Parameters chunkid short waitIfFull bool Returns MemorySegment<T> Type Parameters T Create(MemorySegment) public static MappedConcurrentChunkBasedCircularBuffer Create(MemorySegment memorySegment) Parameters memorySegment MemorySegment Returns MappedConcurrentChunkBasedCircularBuffer Map(MemorySegment) public static MappedConcurrentChunkBasedCircularBuffer Map(MemorySegment memorySegment) Parameters memorySegment MemorySegment Returns MappedConcurrentChunkBasedCircularBuffer SingleThreadedNext() public void SingleThreadedNext() SingleThreadedPeek(out short) public MemorySegment SingleThreadedPeek(out short chunkId) Parameters chunkId short Returns MemorySegment"
  },
  "api/Tomate.MappedConcurrentChunkBasedQueue.DequeueHandle.html": {
    "href": "api/Tomate.MappedConcurrentChunkBasedQueue.DequeueHandle.html",
    "title": "Struct MappedConcurrentChunkBasedQueue.DequeueHandle | Tomate",
    "keywords": "Struct MappedConcurrentChunkBasedQueue.DequeueHandle Namespace Tomate Assembly Tomate.dll Dequeue handle used to access the dequeued chunk's type and data public readonly struct MappedConcurrentChunkBasedQueue.DequeueHandle : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties ChunkData Memory Segment spanning the chunk's data public MemorySegment ChunkData { get; } Property Value MemorySegment ChunkId Chunk's id public ushort ChunkId { get; } Property Value ushort IsDefault If there was no chunk to dequeue, will be true public bool IsDefault { get; } Property Value bool Methods Dispose() Dispose the handle, make the chunk no longer accessible public void Dispose()"
  },
  "api/Tomate.MappedConcurrentChunkBasedQueue.EnqueueHandle-1.html": {
    "href": "api/Tomate.MappedConcurrentChunkBasedQueue.EnqueueHandle-1.html",
    "title": "Struct MappedConcurrentChunkBasedQueue.EnqueueHandle<T> | Tomate",
    "keywords": "Struct MappedConcurrentChunkBasedQueue.EnqueueHandle<T> Namespace Tomate Assembly Tomate.dll Enqueue handle used to set the queued chunk's data [PublicAPI] public readonly struct MappedConcurrentChunkBasedQueue.EnqueueHandle<T> : IDisposable where T : unmanaged Type Parameters T The type of data to store Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks DON'T FORGET TO CALL Dispose() when you've stored the data, otherwise the queue will likely fail at some point to enqueue more items Properties ChunkData The memory segment spanning the chunk's data public MemorySegment<T> ChunkData { get; } Property Value MemorySegment<T> IsDefault Will be true if the chunk failed to be enqueued public bool IsDefault { get; } Property Value bool this[int] Indexer accessor to the chunk's data public ref T this[int i] { get; } Parameters i int Property Value T Value First item of the chunk public ref T Value { get; } Property Value T Methods Dispose() Dispose the handle, make the item ready for dequeue public void Dispose()"
  },
  "api/Tomate.MappedConcurrentChunkBasedQueue.html": {
    "href": "api/Tomate.MappedConcurrentChunkBasedQueue.html",
    "title": "Struct MappedConcurrentChunkBasedQueue | Tomate",
    "keywords": "Struct MappedConcurrentChunkBasedQueue Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MappedConcurrentChunkBasedQueue Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Fields MaxChunkId public const ushort MaxChunkId = 8190 Field Value ushort Properties BufferSize public int BufferSize { get; } Property Value int ReadOffset public long ReadOffset { get; } Property Value long RelativeReadOffset public int RelativeReadOffset { get; } Property Value int RelativeWriteOffset public int RelativeWriteOffset { get; } Property Value int WriteOffset public long WriteOffset { get; } Property Value long Methods Create(MemorySegment) public static MappedConcurrentChunkBasedQueue Create(MemorySegment memorySegment) Parameters memorySegment MemorySegment Returns MappedConcurrentChunkBasedQueue Enqueue<T>(ushort, ushort, TimeSpan?, CancellationToken) public MappedConcurrentChunkBasedQueue.EnqueueHandle<T> Enqueue<T>(ushort chunkId, ushort size = 1, TimeSpan? waitTime = null, CancellationToken token = default) where T : unmanaged Parameters chunkId ushort size ushort waitTime TimeSpan? token CancellationToken Returns MappedConcurrentChunkBasedQueue.EnqueueHandle<T> Type Parameters T Map(MemorySegment) Create a new instance over an existing queue public static MappedConcurrentChunkBasedQueue Map(MemorySegment memorySegment) Parameters memorySegment MemorySegment The memory segment storing the queue Returns MappedConcurrentChunkBasedQueue The instance TryDequeue() public MappedConcurrentChunkBasedQueue.DequeueHandle TryDequeue() Returns MappedConcurrentChunkBasedQueue.DequeueHandle"
  },
  "api/Tomate.MappedExclusiveAccessControl.html": {
    "href": "api/Tomate.MappedExclusiveAccessControl.html",
    "title": "Struct MappedExclusiveAccessControl | Tomate",
    "keywords": "Struct MappedExclusiveAccessControl Namespace Tomate Assembly Tomate.dll Access control supporting multiple processes and only exclusive access [PublicAPI] public struct MappedExclusiveAccessControl Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks The size of this struct is only 8 bytes. Constructors MappedExclusiveAccessControl() Default constructor public MappedExclusiveAccessControl() Methods ReleaseControl() Release a previously gained exclusive access by the calling thread public bool ReleaseControl() Returns bool true if the calling thread had an exclusive access that is now released by calling this method. false if the calling thread was not having an exclusive access. TakeControl(TimeSpan?) Try to gain exclusive access for the calling thread, trying for a given time span if needed. public bool TakeControl(TimeSpan? wait = null) Parameters wait TimeSpan? The time span where the exclusive attempt should be repeatedly made. If null is passed, this method will wait indefinitely until it gain the exclusive access. Doing this could lead to endless waiting if your code is not dead stable. Returns bool true if the exclusive control was successfully made, false if it couldn't be made for the given time span. Examples A safe approach would be doing this var hold = c.TakeControl(TimeSpan.FromMilliseconds(10)); try { if (hold) { // // your code here // } } finally { if (hold) { c.ReleaseControl(); } } Remarks If exclusive control was successfully taken, you must call ReleaseControl() to release it when you're done. Failing to do so would cause other threads to possibly endlessly wait and/or not being able to mutate the resource controlled by this instance. TryTakeControl() Try to gain exclusive access for the calling thread public bool TryTakeControl() Returns bool true if the thread could take the exclusive control, false if the attempt failed because another thread currently holds the exclusive access. Remarks This method won't wait, it will try to get the exclusive access and take it if possible or return a failure if it couldn't. If you are willing to wait to gain exclusive access, call TakeControl(TimeSpan?) instead. WaitUntilReleased() public void WaitUntilReleased()"
  },
  "api/Tomate.MappedStringTable.html": {
    "href": "api/Tomate.MappedStringTable.html",
    "title": "Struct MappedStringTable | Tomate",
    "keywords": "Struct MappedStringTable Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MappedStringTable : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Methods AddString(string) public int AddString(string str) Parameters str string Returns int Create(IPageAllocator, int) public static MappedStringTable Create(IPageAllocator allocator, int pageCapacity) Parameters allocator IPageAllocator pageCapacity int Returns MappedStringTable Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose()"
  },
  "api/Tomate.MathExtensions.html": {
    "href": "api/Tomate.MathExtensions.html",
    "title": "Class MathExtensions | Tomate",
    "keywords": "Class MathExtensions Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class MathExtensions Inheritance object MathExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Bandwidth(int, double) public static string Bandwidth(int size, double elapsed) Parameters size int elapsed double Returns string Bandwidth(long, double) public static string Bandwidth(long size, double elapsed) Parameters size long elapsed double Returns string FriendlyAmount(double) public static string FriendlyAmount(this double val) Parameters val double Returns string FriendlyAmount(int) public static string FriendlyAmount(this int val) Parameters val int Returns string FriendlySize(double) public static string FriendlySize(this double val) Parameters val double Returns string FriendlySize(int) public static string FriendlySize(this int val) Parameters val int Returns string FriendlySize(long) public static string FriendlySize(this long val) Parameters val long Returns string FriendlyTime(double, bool) public static string FriendlyTime(this double elapsed, bool displayRate = true) Parameters elapsed double displayRate bool Returns string IsPowerOf2(int) public static bool IsPowerOf2(this int x) Parameters x int Returns bool IsPowerOf2(long) public static bool IsPowerOf2(this long x) Parameters x long Returns bool NextPowerOf2(int) Return the next power of 2 of the given value public static int NextPowerOf2(this int v) Parameters v int The value Returns int The next power of 2 Remarks If the given value is already a power of 2, this method will return the next one. TicksToSeconds(long) public static double TicksToSeconds(this long ticks) Parameters ticks long Returns double TotalSeconds(int) public static double TotalSeconds(this int ticks) Parameters ticks int Returns double TotalSeconds(long) public static double TotalSeconds(this long ticks) Parameters ticks long Returns double"
  },
  "api/Tomate.MemoryBlock-1.html": {
    "href": "api/Tomate.MemoryBlock-1.html",
    "title": "Struct MemoryBlock<T> | Tomate",
    "keywords": "Struct MemoryBlock<T> Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MemoryBlock<T> : IRefCounted, IDisposable where T : unmanaged Type Parameters T Implements IRefCounted IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors MemoryBlock(MemorySegment<T>) public MemoryBlock(MemorySegment<T> memorySegment) Parameters memorySegment MemorySegment<T> Fields MemorySegment public MemorySegment<T> MemorySegment Field Value MemorySegment<T> Properties IsDefault public bool IsDefault { get; } Property Value bool IsDisposed public bool IsDisposed { get; } Property Value bool MaxAllocationLength public long MaxAllocationLength { get; } Property Value long MemoryManager public IMemoryManager MemoryManager { get; } Property Value IMemoryManager RefCounter public int RefCounter { get; } Property Value int Methods AddRef() public int AddRef() Returns int Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Resize(int) Resize the MemoryBlock public void Resize(int newSize) Parameters newSize int The new size, can't be more than MaxAllocationLength. Remarks This method will change the MemorySegment and its address. Operators implicit operator MemoryBlock(MemoryBlock<T>) public static implicit operator MemoryBlock(MemoryBlock<T> mb) Parameters mb MemoryBlock<T> Returns MemoryBlock implicit operator MemorySegment<T>(MemoryBlock<T>) public static implicit operator MemorySegment<T>(MemoryBlock<T> mb) Parameters mb MemoryBlock<T> Returns MemorySegment<T> implicit operator MemoryBlock<T>(MemorySegment<T>) public static implicit operator MemoryBlock<T>(MemorySegment<T> seg) Parameters seg MemorySegment<T> Returns MemoryBlock<T>"
  },
  "api/Tomate.MemoryBlock.html": {
    "href": "api/Tomate.MemoryBlock.html",
    "title": "Struct MemoryBlock | Tomate",
    "keywords": "Struct MemoryBlock Namespace Tomate Assembly Tomate.dll Represent an allocated block of unmanaged memory [PublicAPI] public struct MemoryBlock : IRefCounted, IDisposable, IEquatable<MemoryBlock> Implements IRefCounted IDisposable IEquatable<MemoryBlock> Inherited Members ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Use one of the implementation of IMemoryManager to allocate a block. Each instance of MemoryBlock has an internal RefCounter with an initial value of 1, that can be incremented with AddRef(). Releasing ownership is done by calling Dispose(), when the RefCounter reaches 0, the memory block is released and no longer usable. Each Memory Block has a Header that precedes its starting address (BlockReferential.GenBlockHeader), the RefCounter resides in this header as well as the Allocator that owns the block. Freeing a Memory Block instance will redirect the operation to the appropriate Allocator. Constructors MemoryBlock(MemorySegment) Construct a MemoryBlock from a MemorySegment public MemoryBlock(MemorySegment memorySegment) Parameters memorySegment MemorySegment The segment with a starting address that matches the block Remarks The size of the MemorySegment should match the real size of the MemoryBlock, higher would likely result to crash, lesser would be unpredictable. Fields MemorySegment The Memory Segment corresponding to the Memory Block public MemorySegment MemorySegment Field Value MemorySegment Remarks There is also an implicit casting operator implicit operator MemorySegment(MemoryBlock) that has the same function. Properties IsDefault If true the instance doesn't refer to a valid MemoryBlock public bool IsDefault { get; } Property Value bool IsDisposed If true the instance is not valid and considered as Default (IsDefault will be also true). public bool IsDisposed { get; } Property Value bool MemoryManager public IMemoryManager MemoryManager { get; } Property Value IMemoryManager RefCounter Access the value of the Reference Counter public int RefCounter { get; } Property Value int Remarks Increasing its value is done through AddRef(), decreasing by calling Dispose(). The MemoryBlock is freed when the counter reaches 0. Methods AddRef() Extend the MemoryBlock lifetime by incrementing its Reference Counter. public int AddRef() Returns int The new Reference Counter Remarks A MemoryBlock can be shared among multiple threads, the only way to guarantee ownership is to call AddRef() to extend it and a matching Dispose() to release it. Cast<T>() public MemoryBlock<T> Cast<T>() where T : unmanaged Returns MemoryBlock<T> Type Parameters T Dispose() Attempt to Dispose and free the MemoryBlock public void Dispose() Remarks If the instance is valid (IsDefault is false), it simply defer to Free(MemoryBlock). If the RefCounter is equal to 1, then the MemoryBlock will be freed. Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. Equals(MemoryBlock) Indicates whether the current object is equal to another object of the same type. public bool Equals(MemoryBlock other) Parameters other MemoryBlock An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Resize(int) Resize the MemoryBlock public void Resize(int newSize) Parameters newSize int The new size, can't be more than MaxAllocationLength. Operators operator ==(MemoryBlock, MemoryBlock) public static bool operator ==(MemoryBlock left, MemoryBlock right) Parameters left MemoryBlock right MemoryBlock Returns bool implicit operator MemorySegment(MemoryBlock) public static implicit operator MemorySegment(MemoryBlock mb) Parameters mb MemoryBlock Returns MemorySegment implicit operator MemoryBlock(MemorySegment) public static implicit operator MemoryBlock(MemorySegment seg) Parameters seg MemorySegment Returns MemoryBlock operator !=(MemoryBlock, MemoryBlock) public static bool operator !=(MemoryBlock left, MemoryBlock right) Parameters left MemoryBlock right MemoryBlock Returns bool"
  },
  "api/Tomate.MemoryManager.ScopedMemorySegment.html": {
    "href": "api/Tomate.MemoryManager.ScopedMemorySegment.html",
    "title": "Struct MemoryManager.ScopedMemorySegment | Tomate",
    "keywords": "Struct MemoryManager.ScopedMemorySegment Namespace Tomate Assembly Tomate.dll public readonly struct MemoryManager.ScopedMemorySegment : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors ScopedMemorySegment(MemoryManager, MemorySegment) public ScopedMemorySegment(MemoryManager owner, MemorySegment segment) Parameters owner MemoryManager segment MemorySegment Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Operators implicit operator MemorySegment(ScopedMemorySegment) public static implicit operator MemorySegment(MemoryManager.ScopedMemorySegment source) Parameters source MemoryManager.ScopedMemorySegment Returns MemorySegment"
  },
  "api/Tomate.MemoryManager.html": {
    "href": "api/Tomate.MemoryManager.html",
    "title": "Class MemoryManager | Tomate",
    "keywords": "Class MemoryManager Namespace Tomate Assembly Tomate.dll Allow to allocate segments of memory [Obsolete(\"Use DefaultMemoryManager instead\")] [PublicAPI] public class MemoryManager : IMemoryManager, IDisposable Inheritance object MemoryManager Implements IMemoryManager IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Thread safety: SINGLE-THREAD Common practice is to store instances of it in a ThreadLocal<T>. Usage: The memory manager is designed to allocate big segments of memory that are part of bigger segments (called PinedMemoryBlock (PMB)). The Memory Manager makes one .net memory allocation per PMB, the block is pinned: it has a fixed address and won't be considered for GC collection, and will be stored in the dedicated GC area for pinned objects (POH). At construction the user specifies the size of each PMB, which typically falls in the range of tens/hundreds of megabytes. Then segments are allocated calling Allocate(int), each segment can't be bigger than the PMB. Each segment has a fixed memory address and is aligned on a cache line (64 bytes). A segment is supposed to be allocated to host a group of objects, doing one segment-one object is to avoid and is far from optimal. (see implementation) Call Free(MemoryBlock) to release a given segment. To release the memory allocated by an instance, either call Clear() or Dispose() or to wait for the instance to be collected. Implementation: This class is certainly the one that uses the most reference instances, but it's fine, because its usage is typically a very low frequency, well should even be punctual. There is a List<T> that references all PMB. Each PMB has its own List<T> that stores one segment per entry. Segments are identified by their address, the PMB list and block lists are keep their entry sorted by address to allow binary search. Constructors MemoryManager(int) Construct an instance of the memory manager public MemoryManager(int pinnedMemoryBlockSize) Parameters pinnedMemoryBlockSize int The size to allocate for each Pinned Memory Block Remarks A Pinned Memory Block should be big, you should think of it as the third level of storage. Level 1 being the object, which is typically grouped in Memory Segments, the level 2. You wont be able to allocate a Memory Segment bigger than a Pinned Memory Block. Properties AllocationPinnedMemoryBlockEpoch Will be incremented every time a new Pinned Memory Block is allocated public int AllocationPinnedMemoryBlockEpoch { get; } Property Value int IsDisposed Check if the instance is disposed or not. public bool IsDisposed { get; } Property Value bool MaxAllocationLength public int MaxAllocationLength { get; } Property Value int MemoryBlockContentCleanup This property only works in DEBUGALLOC mode, it is primarily used to change the content of a memory block being freed, for debugging/troubleshooting purposes. public DefaultMemoryManager.DebugMemoryInit MemoryBlockContentCleanup { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization This property only works in DEBUGALLOC mode, it is primarily used to initialize the content of newly allocated block, for debugging/troubleshooting purposes. public DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryManagerId public int MemoryManagerId { get; } Property Value int MemorySegmentAllocationEpoch Will be incremented every time a new memory segment is allocated public int MemorySegmentAllocationEpoch { get; } Property Value int Store public ref UnmanagedDataStore Store { get; } Property Value UnmanagedDataStore Methods Allocate(int) Allocate a Memory Segment public MemoryBlock Allocate(int length) Parameters length int Length of the segment to allocate. Returns MemoryBlock The segment or an exception will be fired if we couldn't allocate one. Remarks The segment's address will always be aligned on 64 bytes, its size will also be padded on 64 bytes. The segment's address is fixed, you can store it with the lifetime that suits you, it doesn't matter as the segment is part of a Pinned Memory Block that is a pinned allocation (using AllocateUninitializedArray<T>(int, bool) with pinned set to true). Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. AllocateScoped(int) public MemoryManager.ScopedMemorySegment AllocateScoped(int size) Parameters size int Returns MemoryManager.ScopedMemorySegment Allocate<T>(int) Allocate a Memory Segment public MemoryBlock<T> Allocate<T>(int length) where T : unmanaged Parameters length int Length (in {T}) of the segment to allocate. Returns MemoryBlock<T> The segment or an exception will be fired if we couldn't allocate one. Type Parameters T The type of each item of the segment. Remarks The segment's address will always be aligned on 64 bytes, its size will also be padded on 64 bytes. The segment's address is fixed, you can store it with the lifetime that suits you, it doesn't matter as the segment is part of a Pinned Memory Block that is a pinned allocation (using AllocateUninitializedArray<T>(int, bool) with pinned set to true). Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. Clear() Release all the allocated segments, free the memory allocated through .net. public void Clear() Dispose() Dispose the instance, free the allocated memory. public void Dispose() ~MemoryManager() protected ~MemoryManager() Free(MemoryBlock) Free a previously allocated segment public bool Free(MemoryBlock block) Parameters block MemoryBlock The memory block to free Returns bool true if the segment was successfully released, false otherwise. Remarks This method won't prevent you against multiple free attempts on the same segment. If no other segment has been allocated with the same address, then it will return false. But if you allocated another segment which turns out to have the same address and call Free(MemoryBlock) a second time, then it will free the second segment successfully. Exceptions ObjectDisposedException Can't free if the instance is disposed, all segments have been released anyway. Free<T>(MemoryBlock<T>) public bool Free<T>(MemoryBlock<T> memoryBlock) where T : unmanaged Parameters memoryBlock MemoryBlock<T> Returns bool Type Parameters T"
  },
  "api/Tomate.MemoryManagerOverMMF.CreateSettings.html": {
    "href": "api/Tomate.MemoryManagerOverMMF.CreateSettings.html",
    "title": "Struct MemoryManagerOverMMF.CreateSettings | Tomate",
    "keywords": "Struct MemoryManagerOverMMF.CreateSettings Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MemoryManagerOverMMF.CreateSettings Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors CreateSettings(string, string, long, int, bool, int, int) public CreateSettings(string filePathName, string name, long fileSize, int pageSize, bool shrinkOnFinalClose = true, int maxSessionCount = 8, int maxConcurrencyCount = 8) Parameters filePathName string name string fileSize long pageSize int shrinkOnFinalClose bool maxSessionCount int maxConcurrencyCount int Properties FilePathName public readonly string FilePathName { get; } Property Value string FileSize public readonly long FileSize { get; } Property Value long MaxConcurrencyCount public int MaxConcurrencyCount { readonly get; set; } Property Value int MaxSessionCount public int MaxSessionCount { readonly get; set; } Property Value int Name public readonly string Name { get; } Property Value string PageSize public readonly int PageSize { get; } Property Value int ShrinkOnFinalClose public bool ShrinkOnFinalClose { readonly get; set; } Property Value bool"
  },
  "api/Tomate.MemoryManagerOverMMF.SegmentHeader.html": {
    "href": "api/Tomate.MemoryManagerOverMMF.SegmentHeader.html",
    "title": "Struct MemoryManagerOverMMF.SegmentHeader | Tomate",
    "keywords": "Struct MemoryManagerOverMMF.SegmentHeader Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MemoryManagerOverMMF.SegmentHeader Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Fields GenHeader public BlockReferential.GenBlockHeader GenHeader Field Value BlockReferential.GenBlockHeader Link public MemoryManagerOverMMF.TwoWaysLinkedList.Link Link Field Value MemoryManagerOverMMF.TwoWaysLinkedList.Link MaxSegmentSize public static readonly int MaxSegmentSize Field Value int SegmentSize public int SegmentSize Field Value int"
  },
  "api/Tomate.MemoryManagerOverMMF.TwoWaysLinkedList.Link.html": {
    "href": "api/Tomate.MemoryManagerOverMMF.TwoWaysLinkedList.Link.html",
    "title": "Struct MemoryManagerOverMMF.TwoWaysLinkedList.Link | Tomate",
    "keywords": "Struct MemoryManagerOverMMF.TwoWaysLinkedList.Link Namespace Tomate Assembly Tomate.dll public struct MemoryManagerOverMMF.TwoWaysLinkedList.Link Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Fields Next public uint Next Field Value uint Previous public uint Previous Field Value uint Methods Clear() public void Clear()"
  },
  "api/Tomate.MemoryManagerOverMMF.TwoWaysLinkedList.html": {
    "href": "api/Tomate.MemoryManagerOverMMF.TwoWaysLinkedList.html",
    "title": "Struct MemoryManagerOverMMF.TwoWaysLinkedList | Tomate",
    "keywords": "Struct MemoryManagerOverMMF.TwoWaysLinkedList Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MemoryManagerOverMMF.TwoWaysLinkedList Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties Count public int Count { get; } Property Value int FirstId public uint FirstId { get; } Property Value uint IsEmpty public bool IsEmpty { get; } Property Value bool Methods CheckIntegrity(byte*) public bool CheckIntegrity(byte* baseAddress) Parameters baseAddress byte* Returns bool GetLastId(byte*) public uint GetLastId(byte* baseAddress) Parameters baseAddress byte* Returns uint InsertFirst(byte*, uint) public uint InsertFirst(byte* baseAddress, uint nodeId) Parameters baseAddress byte* nodeId uint Returns uint InsertLast(byte*, uint) public uint InsertLast(byte* baseAddress, uint curId) Parameters baseAddress byte* curId uint Returns uint Next(byte*, uint) public uint Next(byte* baseAddress, uint id) Parameters baseAddress byte* id uint Returns uint Previous(byte*, uint) public uint Previous(byte* baseAddress, uint id) Parameters baseAddress byte* id uint Returns uint Remove(byte*, uint) public void Remove(byte* baseAddress, uint id) Parameters baseAddress byte* id uint"
  },
  "api/Tomate.MemoryManagerOverMMF.html": {
    "href": "api/Tomate.MemoryManagerOverMMF.html",
    "title": "Class MemoryManagerOverMMF | Tomate",
    "keywords": "Class MemoryManagerOverMMF Namespace Tomate Assembly Tomate.dll [PublicAPI] public class MemoryManagerOverMMF : IMemoryManager, IPageAllocator, IDisposable Inheritance object MemoryManagerOverMMF Implements IMemoryManager IPageAllocator IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Fields MinSegmentSize public static readonly int MinSegmentSize Field Value int RandomizeContentOnFree public bool RandomizeContentOnFree Field Value bool StoreMaxEntryCount public static readonly int StoreMaxEntryCount Field Value int Properties AllocatedPageCount public int AllocatedPageCount { get; } Property Value int BaseAddress Return the base address of the linear memory block that old all the pages. public byte* BaseAddress { get; } Property Value byte* EndAddress public byte* EndAddress { get; } Property Value byte* IsDisposed Check if the instance is disposed or not. public bool IsDisposed { get; } Property Value bool MMFFilePathName public string MMFFilePathName { get; } Property Value string MMFName public string MMFName { get; } Property Value string MMFSize public long MMFSize { get; } Property Value long MaxAllocationLength public int MaxAllocationLength { get; } Property Value int MemoryBlockContentCleanup This property only works in DEBUGALLOC mode, it is primarily used to change the content of a memory block being freed, for debugging/troubleshooting purposes. public DefaultMemoryManager.DebugMemoryInit MemoryBlockContentCleanup { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization This property only works in DEBUGALLOC mode, it is primarily used to initialize the content of newly allocated block, for debugging/troubleshooting purposes. public DefaultMemoryManager.DebugMemoryInit MemoryBlockContentInitialization { get; set; } Property Value DefaultMemoryManager.DebugMemoryInit MemoryManagerId public int MemoryManagerId { get; } Property Value int PageAllocatorId public int PageAllocatorId { get; } Property Value int PageSize Return the size of one given page public int PageSize { get; } Property Value int Store public ref UnmanagedDataStore Store { get; } Property Value UnmanagedDataStore UserDataArea public MemorySegment UserDataArea { get; } Property Value MemorySegment Methods AddRef(MemorySegment) public int AddRef(MemorySegment memorySegment) Parameters memorySegment MemorySegment Returns int Allocate(int) Allocate a Memory Block public MemoryBlock Allocate(int length) Parameters length int Length of the block to allocate. Returns MemoryBlock The block or an exception will be fired if we couldn't allocate one. Remarks The block's address will always be aligned on at least 16 bytes. The block's address is fixed. Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. AllocatePages(int) Allocate one or many consecutive pages public MemorySegment AllocatePages(int blockSize) Parameters blockSize int Returns MemorySegment The returned memory segment will be PageSize*length. Return default if the allocation failed. Allocate<T>(int) Allocate a Memory Block public MemoryBlock<T> Allocate<T>(int length) where T : unmanaged Parameters length int Length (in {T}) of the segment to allocate. Returns MemoryBlock<T> The segment or an exception will be fired if we couldn't allocate one. Type Parameters T The type of each item of the segment assigned to the block. Remarks The segment's address will always be aligned on 16 bytes, its size will also be padded on 16 bytes. The segment's address is fixed. Exceptions ObjectDisposedException Can't allocate because the object is disposed. OutOfMemoryException The requested size is too big. Clear() Release all the allocated segments, free the memory allocated through .net. public void Clear() Create(CreateSettings) public static MemoryManagerOverMMF Create(MemoryManagerOverMMF.CreateSettings settings) Parameters settings MemoryManagerOverMMF.CreateSettings Returns MemoryManagerOverMMF Defragment() public void Defragment() Delete(string) public static bool Delete(string filePathName) Parameters filePathName string Returns bool Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Free(MemoryBlock) Free a previously allocated block public bool Free(MemoryBlock block) Parameters block MemoryBlock The memory block to free Returns bool true if the block was successfully released, false otherwise. Exceptions ObjectDisposedException Can't free if the instance is disposed, all blocks have been released anyway. FreePages(MemorySegment) Free the pages previously allocated corresponding to the given segment. public bool FreePages(MemorySegment segment) Parameters segment MemorySegment Returns bool true if the operation succeeded, false otherwise. Free<T>(MemoryBlock<T>) public bool Free<T>(MemoryBlock<T> block) where T : unmanaged Parameters block MemoryBlock<T> Returns bool Type Parameters T FromBlockId(int) Convert a BlockId to its corresponding MemorySegment public MemorySegment FromBlockId(int blockId) Parameters blockId int The BlockId previously retrieved with ToBlockId(MemorySegment). Returns MemorySegment The corresponding memory segment or default if it failed. Open(string, string) public static MemoryManagerOverMMF Open(string mmfFilePathName, string mmfName) Parameters mmfFilePathName string mmfName string Returns MemoryManagerOverMMF OpenExisting(string) public static MemoryManagerOverMMF OpenExisting(string mmfName) Parameters mmfName string Returns MemoryManagerOverMMF RemoveResource<T>(String64) public bool RemoveResource<T>(String64 key) where T : unmanaged, IUnmanagedCollection Parameters key String64 Returns bool Type Parameters T ToBlockId(MemorySegment) Convert the given segment's start address to the corresponding BlockId public int ToBlockId(MemorySegment segment) Parameters segment MemorySegment The segment to get the BlockId from Returns int The BlockId, an integer that contains the index of the block and its length encoded as two shorts. TryAddResource<T>(String64, T) public bool TryAddResource<T>(String64 key, T instance) where T : unmanaged, IUnmanagedCollection Parameters key String64 instance T Returns bool Type Parameters T TryGetResource<T>(String64, out bool) public ref T TryGetResource<T>(String64 key, out bool result) where T : unmanaged, IUnmanagedCollection Parameters key String64 result bool Returns T Type Parameters T"
  },
  "api/Tomate.MemoryManagerOverMMFCreateException.html": {
    "href": "api/Tomate.MemoryManagerOverMMFCreateException.html",
    "title": "Class MemoryManagerOverMMFCreateException | Tomate",
    "keywords": "Class MemoryManagerOverMMFCreateException Namespace Tomate Assembly Tomate.dll public class MemoryManagerOverMMFCreateException : Exception, ISerializable Inheritance object Exception MemoryManagerOverMMFCreateException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors MemoryManagerOverMMFCreateException(string, Exception) public MemoryManagerOverMMFCreateException(string msg, Exception innerException) Parameters msg string innerException Exception"
  },
  "api/Tomate.MemorySegment-1.Enumerator.html": {
    "href": "api/Tomate.MemorySegment-1.Enumerator.html",
    "title": "Struct MemorySegment<T>.Enumerator | Tomate",
    "keywords": "Struct MemorySegment<T>.Enumerator Namespace Tomate Assembly Tomate.dll Enumerates the elements of a MemorySegment<T>. public ref struct MemorySegment<T>.Enumerator Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Current Gets the element at the current position of the enumerator. public ref T Current { get; } Property Value T Methods MoveNext() Advances the enumerator to the next element of the segment. public bool MoveNext() Returns bool"
  },
  "api/Tomate.MemorySegment-1.html": {
    "href": "api/Tomate.MemorySegment-1.html",
    "title": "Struct MemorySegment<T> | Tomate",
    "keywords": "Struct MemorySegment<T> Namespace Tomate Assembly Tomate.dll Define a memory segment stored at a fixed address, generic version [PublicAPI] public readonly struct MemorySegment<T> where T : unmanaged Type Parameters T Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This is certainly the fastest way to store/use a memory segment. This allows us to store instances of this struct everywhere we want (as opposed to Span<T> which can't be stored in type declarations). The cast/conversion to Span<T> is as fast as it could be and the user should rely on Span<T> as much as possible, even through direct memory access will be slightly faster. Only work with this type if you are dealing with pinned memory block, otherwise rely on Span<T> Constructors MemorySegment(void*, int) Construct an instance of a Memory Segment public MemorySegment(void* address, int length) Parameters address void* Starting address of the segment length int Length of the segment in {T} (NOT in bytes) Fields Empty public static readonly MemorySegment<T> Empty Field Value MemorySegment<T> _addr public readonly ulong _addr Field Value ulong _data public readonly uint _data Field Value uint Properties Address public T* Address { get; } Property Value T* End public T* End { get; } Property Value T* IsDefault public bool IsDefault { get; } Property Value bool IsInMMF public bool IsInMMF { get; } Property Value bool this[int] public ref T this[int index] { get; } Parameters index int Property Value T Length public int Length { get; } Property Value int Methods AsRef() public ref T AsRef() Returns T AsRef(int) public ref T AsRef(int index) Parameters index int Returns T BinarySearch<TKey>(TKey, BinarySearchComp<T, TKey, long>) public int BinarySearch<TKey>(TKey key, BinarySearchComp<T, TKey, long> f) where TKey : unmanaged Parameters key TKey f BinarySearchComp<T, TKey, long> Returns int Type Parameters TKey Cast() public MemorySegment Cast() Returns MemorySegment Cast<TTo>() public MemorySegment<TTo> Cast<TTo>() where TTo : unmanaged Returns MemorySegment<TTo> Type Parameters TTo GetEnumerator() Gets an enumerator for this segment. public MemorySegment<T>.Enumerator GetEnumerator() Returns MemorySegment<T>.Enumerator Slice(int) public MemorySegment<T> Slice(int start) Parameters start int Returns MemorySegment<T> Slice(int, int) public MemorySegment<T> Slice(int start, int length) Parameters start int length int Returns MemorySegment<T> Split<TA, TB>(int) public (MemorySegment<TA>, MemorySegment<TB>) Split<TA, TB>(int splitOffset) where TA : unmanaged where TB : unmanaged Parameters splitOffset int Returns (MemorySegment<TA>, MemorySegment<TB>) Type Parameters TA TB ToSpan() public Span<T> ToSpan() Returns Span<T> ToSpan<TU>() public Span<TU> ToSpan<TU>() where TU : unmanaged Returns Span<TU> Type Parameters TU Operators implicit operator Span<T>(MemorySegment<T>) public static implicit operator Span<T>(MemorySegment<T> segment) Parameters segment MemorySegment<T> Returns Span<T> implicit operator MemorySegment(MemorySegment<T>) public static implicit operator MemorySegment(MemorySegment<T> source) Parameters source MemorySegment<T> Returns MemorySegment"
  },
  "api/Tomate.MemorySegment.html": {
    "href": "api/Tomate.MemorySegment.html",
    "title": "Struct MemorySegment | Tomate",
    "keywords": "Struct MemorySegment Namespace Tomate Assembly Tomate.dll Define a memory segment stored at a fixed address [PublicAPI] public readonly struct MemorySegment : IEquatable<MemorySegment> Implements IEquatable<MemorySegment> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This is certainly the fastest way to store/use a memory segment. This allows us to store instances of this struct everywhere we want (as opposed to Span<T> which can't be stored in type declarations). The cast/conversion to Span<T> is as fast as it could be and the user should rely on Span<T> as much as possible, even through direct memory access will be slightly faster. Only work with this type if you are dealing with pinned memory block, otherwise rely on Span<T> Constructors MemorySegment(byte*, int) public MemorySegment(byte* address, int length) Parameters address byte* length int Fields Empty public static readonly MemorySegment Empty Field Value MemorySegment _addr public readonly ulong _addr Field Value ulong _data public readonly uint _data Field Value uint Properties Address public byte* Address { get; } Property Value byte* End public byte* End { get; } Property Value byte* IsDefault public bool IsDefault { get; } Property Value bool IsInMMF public bool IsInMMF { get; } Property Value bool Length public int Length { get; } Property Value int Methods Cast<T>() public MemorySegment<T> Cast<T>() where T : unmanaged Returns MemorySegment<T> Type Parameters T Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. Equals(MemorySegment) Indicates whether the current object is equal to another object of the same type. public bool Equals(MemorySegment other) Parameters other MemorySegment An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Slice(int) public MemorySegment Slice(int start) Parameters start int Returns MemorySegment Slice(int, int) public MemorySegment Slice(int start, int length) Parameters start int length int Returns MemorySegment Split(int) public (MemorySegment, MemorySegment) Split(int splitOffset) Parameters splitOffset int Returns (MemorySegment, MemorySegment) Split<TA, TB>(int) public (MemorySegment<TA>, MemorySegment<TB>) Split<TA, TB>(int splitOffset) where TA : unmanaged where TB : unmanaged Parameters splitOffset int Returns (MemorySegment<TA>, MemorySegment<TB>) Type Parameters TA TB ToSpan<T>() public Span<T> ToSpan<T>() where T : unmanaged Returns Span<T> Type Parameters T ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(MemorySegment, MemorySegment) public static bool operator ==(MemorySegment left, MemorySegment right) Parameters left MemorySegment right MemorySegment Returns bool explicit operator MemorySegment(Span<byte>) public static explicit operator MemorySegment(Span<byte> span) Parameters span Span<byte> Returns MemorySegment implicit operator byte*(MemorySegment) public static implicit operator byte*(MemorySegment segment) Parameters segment MemorySegment Returns byte* implicit operator Span<byte>(MemorySegment) public static implicit operator Span<byte>(MemorySegment segment) Parameters segment MemorySegment Returns Span<byte> implicit operator void*(MemorySegment) public static implicit operator void*(MemorySegment segment) Parameters segment MemorySegment Returns void* operator !=(MemorySegment, MemorySegment) public static bool operator !=(MemorySegment left, MemorySegment right) Parameters left MemorySegment right MemorySegment Returns bool"
  },
  "api/Tomate.MemorySegments-2.html": {
    "href": "api/Tomate.MemorySegments-2.html",
    "title": "Struct MemorySegments<T1, T2> | Tomate",
    "keywords": "Struct MemorySegments<T1, T2> Namespace Tomate Assembly Tomate.dll public readonly struct MemorySegments<T1, T2> where T1 : unmanaged where T2 : unmanaged Type Parameters T1 T2 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors MemorySegments(MemorySegment, int, int) public MemorySegments(MemorySegment segment, int length1, int length2) Parameters segment MemorySegment length1 int length2 int Properties Segment1 public MemorySegment<T1> Segment1 { get; } Property Value MemorySegment<T1> Segment2 public MemorySegment<T2> Segment2 { get; } Property Value MemorySegment<T2>"
  },
  "api/Tomate.MemorySegments-3.html": {
    "href": "api/Tomate.MemorySegments-3.html",
    "title": "Struct MemorySegments<T1, T2, T3> | Tomate",
    "keywords": "Struct MemorySegments<T1, T2, T3> Namespace Tomate Assembly Tomate.dll public readonly struct MemorySegments<T1, T2, T3> where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged Type Parameters T1 T2 T3 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors MemorySegments(MemorySegment, int, int, int) public MemorySegments(MemorySegment segment, int length1, int length2, int length3) Parameters segment MemorySegment length1 int length2 int length3 int Properties Segment1 public MemorySegment<T1> Segment1 { get; } Property Value MemorySegment<T1> Segment2 public MemorySegment<T2> Segment2 { get; } Property Value MemorySegment<T2> Segment3 public MemorySegment<T3> Segment3 { get; } Property Value MemorySegment<T3>"
  },
  "api/Tomate.MemorySegments-4.html": {
    "href": "api/Tomate.MemorySegments-4.html",
    "title": "Struct MemorySegments<T1, T2, T3, T4> | Tomate",
    "keywords": "Struct MemorySegments<T1, T2, T3, T4> Namespace Tomate Assembly Tomate.dll public readonly struct MemorySegments<T1, T2, T3, T4> where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged Type Parameters T1 T2 T3 T4 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors MemorySegments(MemorySegment, int, int, int, int) public MemorySegments(MemorySegment segment, int length1, int length2, int length3, int length4) Parameters segment MemorySegment length1 int length2 int length3 int length4 int Properties Segment1 public MemorySegment<T1> Segment1 { get; } Property Value MemorySegment<T1> Segment2 public MemorySegment<T2> Segment2 { get; } Property Value MemorySegment<T2> Segment3 public MemorySegment<T3> Segment3 { get; } Property Value MemorySegment<T3> Segment4 public MemorySegment<T4> Segment4 { get; } Property Value MemorySegment<T4>"
  },
  "api/Tomate.MemorySegments-5.html": {
    "href": "api/Tomate.MemorySegments-5.html",
    "title": "Struct MemorySegments<T1, T2, T3, T4, T5> | Tomate",
    "keywords": "Struct MemorySegments<T1, T2, T3, T4, T5> Namespace Tomate Assembly Tomate.dll public readonly struct MemorySegments<T1, T2, T3, T4, T5> where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged Type Parameters T1 T2 T3 T4 T5 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors MemorySegments(MemorySegment, int, int, int, int, int) public MemorySegments(MemorySegment segment, int length1, int length2, int length3, int length4, int length5) Parameters segment MemorySegment length1 int length2 int length3 int length4 int length5 int Properties Segment1 public MemorySegment<T1> Segment1 { get; } Property Value MemorySegment<T1> Segment2 public MemorySegment<T2> Segment2 { get; } Property Value MemorySegment<T2> Segment3 public MemorySegment<T3> Segment3 { get; } Property Value MemorySegment<T3> Segment4 public MemorySegment<T4> Segment4 { get; } Property Value MemorySegment<T4> Segment5 public MemorySegment<T5> Segment5 { get; } Property Value MemorySegment<T5>"
  },
  "api/Tomate.MemoryView-1.html": {
    "href": "api/Tomate.MemoryView-1.html",
    "title": "Struct MemoryView<T> | Tomate",
    "keywords": "Struct MemoryView<T> Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct MemoryView<T> where T : unmanaged Type Parameters T Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors MemoryView(MemorySegment<T>) public MemoryView(MemorySegment<T> memorySegment) Parameters memorySegment MemorySegment<T> Fields MemorySegment public readonly MemorySegment<T> MemorySegment Field Value MemorySegment<T> Properties IsDefault public bool IsDefault { get; } Property Value bool IsEndReached public bool IsEndReached { get; } Property Value bool this[int] Random access, doesn't change Position public ref T this[int index] { get; } Parameters index int Index of the item to access Property Value T Reference to the item for read/write operations Length public int Length { get; } Property Value int Position Get/set the position public int Position { get; set; } Property Value int Remarks There is no bound check, if the new position is out of bound then IsEndReached will be return true Methods BeginReserve(int, out Span<T>) public bool BeginReserve(int maxSizeRequired, out Span<T> storeArea) Parameters maxSizeRequired int storeArea Span<T> Returns bool EndReserve(int) public void EndReserve(int writtenSize) Parameters writtenSize int Fetch(int, out MemorySegment<T>) public bool Fetch(int length, out MemorySegment<T> readArea) Parameters length int readArea MemorySegment<T> Returns bool Fetch<TR>() public ref TR Fetch<TR>() where TR : unmanaged Returns TR Type Parameters TR Fetch<TD>(int, out MemorySegment<TD>) public bool Fetch<TD>(int length, out MemorySegment<TD> readArea) where TD : unmanaged Parameters length int readArea MemorySegment<TD> Returns bool Type Parameters TD GetReservedArea(int, out Span<T>) public bool GetReservedArea(int maxLength, out Span<T> area) Parameters maxLength int area Span<T> Returns bool Reserve(int, out int) public bool Reserve(int length, out int index) Parameters length int index int Returns bool Reserve(int, out Span<T>) public bool Reserve(int length, out Span<T> storeArea) Parameters length int storeArea Span<T> Returns bool Reserve(out int) public bool Reserve(out int index) Parameters index int Returns bool Reset() public void Reset() Skip(int) public bool Skip(int offset) Parameters offset int Returns bool Store(Span<T>) public bool Store(Span<T> data) Parameters data Span<T> Returns bool"
  },
  "api/Tomate.MiscExtensions.html": {
    "href": "api/Tomate.MiscExtensions.html",
    "title": "Class MiscExtensions | Tomate",
    "keywords": "Class MiscExtensions Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class MiscExtensions Inheritance object MiscExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ToTimeSpan(long) public static TimeSpan ToTimeSpan(this long v) Parameters v long Returns TimeSpan"
  },
  "api/Tomate.MockProcessProvider.html": {
    "href": "api/Tomate.MockProcessProvider.html",
    "title": "Class MockProcessProvider | Tomate",
    "keywords": "Class MockProcessProvider Namespace Tomate Assembly Tomate.dll [PublicAPI] public class MockProcessProvider : IProcessProvider Inheritance object MockProcessProvider Implements IProcessProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties CurrentProcessId public int CurrentProcessId { get; set; } Property Value int DefaultProcessId public int DefaultProcessId { get; set; } Property Value int Methods IsProcessAlive(int) public bool IsProcessAlive(int processId) Parameters processId int Returns bool UnregisterProcess(int) public void UnregisterProcess(int secondProcessId) Parameters secondProcessId int"
  },
  "api/Tomate.MurmurHash2.html": {
    "href": "api/Tomate.MurmurHash2.html",
    "title": "Class MurmurHash2 | Tomate",
    "keywords": "Class MurmurHash2 Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class MurmurHash2 Inheritance object MurmurHash2 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Hash(byte*, int, uint) public static uint Hash(byte* dataAddr, int length, uint seed) Parameters dataAddr byte* length int seed uint Returns uint Hash(byte[]) public static uint Hash(byte[] data) Parameters data byte[] Returns uint Hash(ReadOnlySpan<byte>) public static uint Hash(ReadOnlySpan<byte> data) Parameters data ReadOnlySpan<byte> Returns uint"
  },
  "api/Tomate.PackExtensions.html": {
    "href": "api/Tomate.PackExtensions.html",
    "title": "Class PackExtensions | Tomate",
    "keywords": "Class PackExtensions Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class PackExtensions Inheritance object PackExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ByteLevelSize(uint, bool) public static byte ByteLevelSize(this uint n, bool writeZero = false) Parameters n uint writeZero bool Returns byte High(ushort) public static byte High(this ushort n) Parameters n ushort Returns byte High(ref ushort, byte) public static void High(this ref ushort n, byte val) Parameters n ushort val byte High(ref ushort, sbyte) public static void High(this ref ushort n, sbyte val) Parameters n ushort val sbyte High(uint) public static ushort High(this uint n) Parameters n uint Returns ushort High(ref uint, short) public static void High(this ref uint n, short val) Parameters n uint val short High(ref uint, ushort) public static void High(this ref uint n, ushort val) Parameters n uint val ushort High(ulong) public static uint High(this ulong n) Parameters n ulong Returns uint High(ref ulong, int) public static void High(this ref ulong n, int val) Parameters n ulong val int High(ref ulong, uint) public static void High(this ref ulong n, uint val) Parameters n ulong val uint HighS(ushort) public static sbyte HighS(this ushort n) Parameters n ushort Returns sbyte HighS(uint) public static short HighS(this uint n) Parameters n uint Returns short HighS(ulong) public static int HighS(this ulong n) Parameters n ulong Returns int Low(ushort) public static byte Low(this ushort n) Parameters n ushort Returns byte Low(ref ushort, byte) public static void Low(this ref ushort n, byte val) Parameters n ushort val byte Low(ref ushort, sbyte) public static void Low(this ref ushort n, sbyte val) Parameters n ushort val sbyte Low(uint) public static ushort Low(this uint n) Parameters n uint Returns ushort Low(ref uint, short) public static void Low(this ref uint n, short val) Parameters n uint val short Low(ref uint, ushort) public static void Low(this ref uint n, ushort val) Parameters n uint val ushort Low(ulong) public static uint Low(this ulong n) Parameters n ulong Returns uint Low(ref ulong, int) public static void Low(this ref ulong n, int val) Parameters n ulong val int Low(ref ulong, uint) public static void Low(this ref ulong n, uint val) Parameters n ulong val uint LowS(ushort) public static sbyte LowS(this ushort n) Parameters n ushort Returns sbyte LowS(uint) public static short LowS(this uint n) Parameters n uint Returns short LowS(ulong) public static int LowS(this ulong n) Parameters n ulong Returns int Pack(ref int, short, short) public static void Pack(this ref int n, short high, short low) Parameters n int high short low short Pack(ref int, ushort, ushort) public static void Pack(this ref int n, ushort high, ushort low) Parameters n int high ushort low ushort Pack(ref ushort, byte, byte) public static void Pack(this ref ushort n, byte high, byte low) Parameters n ushort high byte low byte Pack(ref ushort, sbyte, sbyte) public static void Pack(this ref ushort n, sbyte high, sbyte low) Parameters n ushort high sbyte low sbyte Pack(ref uint, short, short) public static void Pack(this ref uint n, short high, short low) Parameters n uint high short low short Pack(ref uint, ushort, ushort) public static void Pack(this ref uint n, ushort high, ushort low) Parameters n uint high ushort low ushort Pack(ref ulong, int, int) public static void Pack(this ref ulong n, int high, int low) Parameters n ulong high int low int Pack(ref ulong, ushort, ushort, uint) public static void Pack(this ref ulong n, ushort highUHigh, ushort highULow, uint low) Parameters n ulong highUHigh ushort highULow ushort low uint Pack(ref ulong, uint, uint) public static void Pack(this ref ulong n, uint high, uint low) Parameters n ulong high uint low uint ReadByteLevel(ref int, ref MemoryView<byte>, int) public static void ReadByteLevel(this ref int n, ref MemoryView<byte> src, int byteSize) Parameters n int src MemoryView<byte> byteSize int ReadByteLevel(ref uint, void*, int) public static void ReadByteLevel(this ref uint n, void* addr, int byteSize) Parameters n uint addr void* byteSize int ReadByteLevel(ref uint, ref MemoryView<byte>, int) public static void ReadByteLevel(this ref uint n, ref MemoryView<byte> src, int byteSize) Parameters n uint src MemoryView<byte> byteSize int Unpack(ushort) public static (byte, byte) Unpack(this ushort n) Parameters n ushort Returns (byte, byte) Unpack(uint) public static (ushort, ushort) Unpack(this uint n) Parameters n uint Returns (ushort, ushort) Unpack(ulong) public static (uint, uint) Unpack(this ulong n) Parameters n ulong Returns (uint, uint) UnpackS(ushort) public static (sbyte, sbyte) UnpackS(this ushort n) Parameters n ushort Returns (sbyte, sbyte) UnpackS(uint) public static (short, short) UnpackS(this uint n) Parameters n uint Returns (short, short) UnpackS(ulong) public static (int, int) UnpackS(this ulong n) Parameters n ulong Returns (int, int) WriteByteLevel(uint, ref byte*, bool) public static int WriteByteLevel(this uint n, ref byte* dest, bool writeZero = false) Parameters n uint dest byte* writeZero bool Returns int"
  },
  "api/Tomate.PaddingExtensions.html": {
    "href": "api/Tomate.PaddingExtensions.html",
    "title": "Class PaddingExtensions | Tomate",
    "keywords": "Class PaddingExtensions Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class PaddingExtensions Inheritance object PaddingExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pad(int, int) public static int Pad(this int v, int paddingSize) Parameters v int paddingSize int Returns int Pad16(int) public static int Pad16(this int v) Parameters v int Returns int Pad32(int) public static int Pad32(this int v) Parameters v int Returns int Pad4(int) public static int Pad4(this int v) Parameters v int Returns int Pad8(int) public static int Pad8(this int v) Parameters v int Returns int Pad<T>(int) public static int Pad<T>(this int v) where T : unmanaged Parameters v int Returns int Type Parameters T"
  },
  "api/Tomate.PageAllocator.html": {
    "href": "api/Tomate.PageAllocator.html",
    "title": "Class PageAllocator | Tomate",
    "keywords": "Class PageAllocator Namespace Tomate Assembly Tomate.dll [PublicAPI] public class PageAllocator : IDisposable, IPageAllocator Inheritance object PageAllocator Implements IDisposable IPageAllocator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors PageAllocator(int, int) public PageAllocator(int pageSize, int pageCount) Parameters pageSize int pageCount int Properties BaseAddress Return the base address of the linear memory block that old all the pages. public byte* BaseAddress { get; } Property Value byte* IsDisposed Check if the instance is disposed or not. public bool IsDisposed { get; } Property Value bool PageAllocationEpoch Will be incremented every time a new page is allocated public int PageAllocationEpoch { get; } Property Value int PageAllocatorId public int PageAllocatorId { get; } Property Value int PageCount public int PageCount { get; } Property Value int PageSize Return the size of one given page public int PageSize { get; } Property Value int Methods AllocatePages(int) Allocate one or many consecutive pages public MemorySegment AllocatePages(int pageCount) Parameters pageCount int Returns MemorySegment The returned memory segment will be PageSize*length. Return default if the allocation failed. Clear() public void Clear() Dispose() Dispose the instance, free the allocated memory. public void Dispose() FreeHeapPinnedArray(MemorySegment<byte>) public static bool FreeHeapPinnedArray(MemorySegment<byte> segment) Parameters segment MemorySegment<byte> Returns bool FreePages(MemorySegment) Free the pages previously allocated corresponding to the given segment. public bool FreePages(MemorySegment pages) Parameters pages MemorySegment The memory segment spanning all the pages to free. Returns bool true if the operation succeeded, false otherwise. FromBlockId(int) Convert a BlockId to its corresponding MemorySegment public MemorySegment FromBlockId(int blockId) Parameters blockId int The BlockId previously retrieved with ToBlockId(MemorySegment). Returns MemorySegment The corresponding memory segment or default if it failed. ToBlockId(MemorySegment) Convert the given segment's start address to the corresponding BlockId public int ToBlockId(MemorySegment segment) Parameters segment MemorySegment The segment to get the BlockId from Returns int The BlockId, an integer that contains the index of the block and its length encoded as two shorts."
  },
  "api/Tomate.ProfileThis.Handle.html": {
    "href": "api/Tomate.ProfileThis.Handle.html",
    "title": "Struct ProfileThis.Handle | Tomate",
    "keywords": "Struct ProfileThis.Handle Namespace Tomate Assembly Tomate.dll public ref struct ProfileThis.Handle Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Handle(ref ProfileThis) public Handle(ref ProfileThis owner) Parameters owner ProfileThis Methods Dispose() public void Dispose()"
  },
  "api/Tomate.ProfileThis.html": {
    "href": "api/Tomate.ProfileThis.html",
    "title": "Struct ProfileThis | Tomate",
    "keywords": "Struct ProfileThis Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct ProfileThis Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties Duration public readonly TimeSpan Duration { get; } Property Value TimeSpan Methods Start(ref ProfileThis) public static ProfileThis.Handle Start(ref ProfileThis o) Parameters o ProfileThis Returns ProfileThis.Handle Operators implicit operator TimeSpan(ProfileThis) public static implicit operator TimeSpan(ProfileThis pt) Parameters pt ProfileThis Returns TimeSpan"
  },
  "api/Tomate.QuickRand.html": {
    "href": "api/Tomate.QuickRand.html",
    "title": "Class QuickRand | Tomate",
    "keywords": "Class QuickRand Namespace Tomate Assembly Tomate.dll Quick random generation number [PublicAPI] public static class QuickRand Inheritance object QuickRand Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Also known as the Marsaglia's xor-shift generator, it's very fast and pretty decent for the distribution Methods Next() Get the next randomly generated number public static int Next() Returns int"
  },
  "api/Tomate.RewriteMemoryView.html": {
    "href": "api/Tomate.RewriteMemoryView.html",
    "title": "Struct RewriteMemoryView | Tomate",
    "keywords": "Struct RewriteMemoryView Namespace Tomate Assembly Tomate.dll Rewrite the content of the view by processing its data [PublicAPI] public struct RewriteMemoryView Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors RewriteMemoryView(MemorySegment) public RewriteMemoryView(MemorySegment memorySegment) Parameters memorySegment MemorySegment Fields MemorySegment public readonly MemorySegment MemorySegment Field Value MemorySegment Properties ReadPosition public int ReadPosition { get; } Property Value int WritePosition public int WritePosition { get; } Property Value int Methods Fetch<T>(MemorySegment<T>) public bool Fetch<T>(MemorySegment<T> dest) where T : unmanaged Parameters dest MemorySegment<T> Returns bool Type Parameters T Reserve<T>(int) public MemorySegment<T> Reserve<T>(int length) where T : unmanaged Parameters length int Returns MemorySegment<T> Type Parameters T"
  },
  "api/Tomate.SegmentConstructException.html": {
    "href": "api/Tomate.SegmentConstructException.html",
    "title": "Class SegmentConstructException | Tomate",
    "keywords": "Class SegmentConstructException Namespace Tomate Assembly Tomate.dll [PublicAPI] public class SegmentConstructException : Exception, ISerializable Inheritance object Exception SegmentConstructException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors SegmentConstructException(string) public SegmentConstructException(string message) Parameters message string"
  },
  "api/Tomate.SmallLock.html": {
    "href": "api/Tomate.SmallLock.html",
    "title": "Struct SmallLock | Tomate",
    "keywords": "Struct SmallLock Namespace Tomate Assembly Tomate.dll An interprocess lock allowing control over concurrent accesses for a given (immaterial) resource. [PublicAPI] public struct SmallLock Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks As all interprocess compatible types, `SmallLock` is designed to be compatible with storing instances on a MemoryManagerOverMMF. One of the resulted constraint is you have to specify at construction the maximum level of concurrency, resizing data on the fly would make the implementation of this type way harder. This type would apparently itself to Monitor but is interprocess compatible (and simpler, as more limited). Properties ConcurrencyCapacity Get the maximum concurrency level the lock can support. public int ConcurrencyCapacity { get; } Property Value int Remarks This value is determined at construction, base on the size of the data segment that is given. The lock can't support more concurrent operations (e.g.: simultaneous/concurrent calls to Enter() for instance) than given at construction. ConcurrencyCounter Get the current concurrency level, at the time this property is accessed public int ConcurrencyCounter { get; } Property Value int IsEntered Return true if the lock is taken by someone, false otherwise. public bool IsEntered { get; } Property Value bool LockId Get the lockId (the one given during Enter()) that is currently holding the lock public int LockId { get; } Property Value int Remarks 0 means the lock is not held. LockedByProcess Get the id of the processing holding the lock public int LockedByProcess { get; } Property Value int Remarks The return id is equivalent to CurrentProcessId for the calling process. 0 means the lock is not held. Methods ComputeSegmentSize(ushort) Helper method determining the size of the MemorySegment needed to store a SmallLock supporting the given concurrency level public static int ComputeSegmentSize(ushort concurrencyLevel) Parameters concurrencyLevel ushort The required concurrency level, that is, the number of processes/threads that would be able to use the SmallLock instance concurrently. Returns int The size the MemorySegment should be to store one instance. Create(MemorySegment) Create a new instance, stored in the given memory location public static SmallLock Create(MemorySegment segment) Parameters segment MemorySegment The memory segment used to store the instance, the max concurrency will determined by the size of this segment. Returns SmallLock The created instance. Enter() Acquire the lock with an exclusive access public void Enter() Remarks This method will use the process Id and thread Id to identify this access request, if the lock is already hold by someone else, it will wait an indeterminate amount of time to get it. Call Exit() to release access. Exceptions SmallLockConcurrencyExceededException Can't enter because the maximum count of concurrency level is already reached. Exit() Release the exclusive access on the lock public void Exit() Remarks This method must be called after a successful Enter() Exit(int) Release the exclusive access on the lock public void Exit(int lockId) Parameters lockId int Remarks This method must be called after a successful TryEnter(out bool, int, TimeSpan) or TryEnter(out bool, out bool, int, TimeSpan) Map(MemorySegment) Create a C# instance of SmallLock by mapping to an existing (and previously created) one. public static SmallLock Map(MemorySegment segment) Parameters segment MemorySegment The memory segment that contains the data of the SmallLock to map against. Returns SmallLock The instance Remarks See MemoryManagerOverMMF for more detail of how this is working TryEnter(out bool, out bool, int, TimeSpan) Attempt to acquire the lock with an exclusive access public void TryEnter(out bool lockTaken, out bool resumedOnCrashedProcess, int lockId = 0, TimeSpan timeOut = default) Parameters lockTaken bool If true the user will have to call Exit(int) because the lock was successfully taken, false otherwise. The most likely reason for this arg to be false is we couldn't acquire the lock in due time. resumedOnCrashedProcess bool If the previous holder of the lock was another process that crashed without releasing it, we will be set to true to indicate we couldn't wait the lock to be released to switch to the next in line. lockId int Id to assign to the lock, if 0 the thread's ManagedThreadId will be used. timeOut TimeSpan If the lock couldn't be acquired during this time span, we give up. default(TimeSpan) will be considered as waiting forever. Remarks Call Exit(int) to release access. Exceptions SmallLockConcurrencyExceededException Can't enter because the maximum count of concurrency level is already reached. TryEnter(out bool, int, TimeSpan) Attempt to acquire the lock with an exclusive access public void TryEnter(out bool lockTaken, int lockId = 0, TimeSpan timeOut = default) Parameters lockTaken bool If true the user will have to call Exit(int) because the lock was successfully taken, false otherwise. The most likely reason for this arg to be false is we couldn't acquire the lock in due time. lockId int Id to assign to the lock, if 0 the thread's ManagedThreadId will be used. timeOut TimeSpan If the lock couldn't be acquired during this time span, we give up. default(TimeSpan) will be considered as waiting forever. Remarks Call Exit(int) to release access. Exceptions SmallLockConcurrencyExceededException Can't enter because the maximum count of concurrency level is already reached."
  },
  "api/Tomate.SmallLockConcurrencyExceededException.html": {
    "href": "api/Tomate.SmallLockConcurrencyExceededException.html",
    "title": "Class SmallLockConcurrencyExceededException | Tomate",
    "keywords": "Class SmallLockConcurrencyExceededException Namespace Tomate Assembly Tomate.dll Exception triggered when an operation can't be performed to due a greater number of concurrent operations than SmallLock can handle. public class SmallLockConcurrencyExceededException : Exception, ISerializable Inheritance object Exception SmallLockConcurrencyExceededException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors SmallLockConcurrencyExceededException(string) public SmallLockConcurrencyExceededException(string message) Parameters message string"
  },
  "api/Tomate.StoreInExtensions.html": {
    "href": "api/Tomate.StoreInExtensions.html",
    "title": "Class StoreInExtensions | Tomate",
    "keywords": "Class StoreInExtensions Namespace Tomate Assembly Tomate.dll [PublicAPI] public static class StoreInExtensions Inheritance object StoreInExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SizeInLong(int) public static int SizeInLong(this int bytes) Parameters bytes int Returns int SizeInLong(ushort) public static int SizeInLong(this ushort bytes) Parameters bytes ushort Returns int"
  },
  "api/Tomate.String256.html": {
    "href": "api/Tomate.String256.html",
    "title": "Struct String256 | Tomate",
    "keywords": "Struct String256 Namespace Tomate Assembly Tomate.dll Stores a string using UTF8 format with a max size of 256-bytes. [PublicAPI] public struct String256 : IComparable<String256>, IEquatable<String256> Implements IComparable<String256> IEquatable<String256> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This struct stores 256 bytes as a fixed array of byte, the string is stores in the buffer encoded with UTF8. So the size of this struct is fixed and always of 256 bytes. Constructors String256(byte*, int) Construct a String256 instance from a memory area containing the string public String256(byte* stringAddr, int length = 256) Parameters stringAddr byte* Address of the memory area containing the UTF8 string data length int Length of the stringAddr memory area String256(string) Construct a String256 instance from a string. THROW if the string is too big! public String256(string source) Parameters source string The string to use as input. If the string's UTF8 equivalent is sized more than 255bytes it will throw an exception. Exceptions ArgumentOutOfRangeException is thrown if the source contains a string that exceed the max size of 255 bytes. Properties AsString Get or set the content of the string. READ remarks! public string AsString { get; set; } Property Value string Remarks Setting a new string WILL NOT throw if it is bigger, the string will be truncated. This behavior is intentionally different from String256(string) constructor. Methods CompareTo(String256) Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object. public int CompareTo(String256 other) Parameters other String256 An object to compare with this instance. Returns int A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance precedes other in the sort order. Zero This instance occurs in the same position in the sort order as other. Greater than zero This instance follows other in the sort order. Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. Equals(String256) Indicates whether the current object is equal to another object of the same type. public bool Equals(String256 other) Parameters other String256 An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. GetHashCode() Compute the hash code of the string instance public override int GetHashCode() Returns int The hash code Remarks The MurmurHash2 hashing is used. Map(string, void*) public static String256* Map(string source, void* address) Parameters source string address void* Returns String256* ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(String256, String256) public static bool operator ==(String256 left, String256 right) Parameters left String256 right String256 Returns bool implicit operator String256(string) Cast a string to String256. public static implicit operator String256(string str) Parameters str string The string to cast Returns String256 The String256 instance. operator !=(String256, String256) public static bool operator !=(String256 left, String256 right) Parameters left String256 right String256 Returns bool"
  },
  "api/Tomate.String64.html": {
    "href": "api/Tomate.String64.html",
    "title": "Struct String64 | Tomate",
    "keywords": "Struct String64 Namespace Tomate Assembly Tomate.dll Stores a string using UTF8 format with a max size of 64-bytes. [PublicAPI] public struct String64 : IComparable<String64>, IEquatable<String64> Implements IComparable<String64> IEquatable<String64> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This struct stores 64 bytes as a fixed array of byte, the string is stores in the buffer encoded with UTF8. So the size of this struct is fixed and always of 64 bytes. Constructors String64(byte*, int) Construct a String64 instance from a memory area containing the string public String64(byte* stringAddr, int length = 64) Parameters stringAddr byte* Address of the memory area containing the UTF8 string data length int Length of the stringAddr memory area String64(string) Construct a String64 instance from a string. THROW if the string is too big! public String64(string source) Parameters source string The string to use as input. If the string's UTF8 equivalent is sized more than 63bytes it will throw an exception. Exceptions ArgumentOutOfRangeException is thrown if the source contains a string that exceed the max size of 63 bytes. Properties AsString Get or set the content of the string. READ remarks! public string AsString { get; set; } Property Value string Remarks Setting a new string WILL NOT throw if it is bigger, the string will be truncated. This behavior is intentionally different from String64(string) constructor. Methods CompareTo(String64) Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object. public int CompareTo(String64 other) Parameters other String64 An object to compare with this instance. Returns int A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance precedes other in the sort order. Zero This instance occurs in the same position in the sort order as other. Greater than zero This instance follows other in the sort order. Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. Equals(String64) Indicates whether the current object is equal to another object of the same type. public bool Equals(String64 other) Parameters other String64 An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. GetHashCode() Compute the hash code of the string instance public override int GetHashCode() Returns int The hash code Remarks The MurmurHash2 hashing is used. ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(String64, String64) public static bool operator ==(String64 left, String64 right) Parameters left String64 right String64 Returns bool implicit operator String64(string) Cast a string to String64. public static implicit operator String64(string str) Parameters str string The string to cast Returns String64 The String64 instance. operator !=(String64, String64) public static bool operator !=(String64 left, String64 right) Parameters left String64 right String64 Returns bool"
  },
  "api/Tomate.TimeSegment.html": {
    "href": "api/Tomate.TimeSegment.html",
    "title": "Struct TimeSegment | Tomate",
    "keywords": "Struct TimeSegment Namespace Tomate Assembly Tomate.dll [PublicAPI] public readonly struct TimeSegment Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors TimeSegment(long, long) public TimeSegment(long beginTicks, long endTicks) Parameters beginTicks long endTicks long TimeSegment(TimeSpan, TimeSpan) public TimeSegment(TimeSpan begin, TimeSpan end) Parameters begin TimeSpan end TimeSpan Properties Begin public TimeSpan Begin { get; } Property Value TimeSpan BeginTicks public long BeginTicks { get; } Property Value long DeltaTick public long DeltaTick { get; } Property Value long Duration public TimeSpan Duration { get; } Property Value TimeSpan End public TimeSpan End { get; } Property Value TimeSpan EndTicks public long EndTicks { get; } Property Value long Methods IsOverlapping(TimeSegment) public bool IsOverlapping(TimeSegment other) Parameters other TimeSegment Returns bool ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator +(long, TimeSegment) public static TimeSegment operator +(long offset, TimeSegment ts) Parameters offset long ts TimeSegment Returns TimeSegment"
  },
  "api/Tomate.TwoWaysLinkedList-1.Accessor.html": {
    "href": "api/Tomate.TwoWaysLinkedList-1.Accessor.html",
    "title": "Delegate TwoWaysLinkedList<T>.Accessor | Tomate",
    "keywords": "Delegate TwoWaysLinkedList<T>.Accessor Namespace Tomate Assembly Tomate.dll public delegate ref TwoWaysLinkedList<T>.Link TwoWaysLinkedList<T>.Accessor(T id) Parameters id T Returns TwoWaysLinkedList<T>.Link Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T)"
  },
  "api/Tomate.TwoWaysLinkedList-1.Link.html": {
    "href": "api/Tomate.TwoWaysLinkedList-1.Link.html",
    "title": "Struct TwoWaysLinkedList<T>.Link | Tomate",
    "keywords": "Struct TwoWaysLinkedList<T>.Link Namespace Tomate Assembly Tomate.dll public struct TwoWaysLinkedList<T>.Link Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Fields Next public T Next Field Value T Previous public T Previous Field Value T"
  },
  "api/Tomate.TwoWaysLinkedList-1.html": {
    "href": "api/Tomate.TwoWaysLinkedList-1.html",
    "title": "Struct TwoWaysLinkedList<T> | Tomate",
    "keywords": "Struct TwoWaysLinkedList<T> Namespace Tomate Assembly Tomate.dll [PublicAPI] public struct TwoWaysLinkedList<T> where T : unmanaged Type Parameters T Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Constructors TwoWaysLinkedList(Func<T>, Accessor) public TwoWaysLinkedList(Func<T> allocator, TwoWaysLinkedList<T>.Accessor accessor) Parameters allocator Func<T> accessor TwoWaysLinkedList<T>.Accessor Properties Count public int Count { get; } Property Value int FirstId public T FirstId { get; } Property Value T IsEmpty public bool IsEmpty { get; } Property Value bool LastId public T LastId { get; } Property Value T Methods CheckIntegrity() public bool CheckIntegrity() Returns bool Insert(T, T) public T Insert(T leftId, T nodeId) Parameters leftId T nodeId T Returns T InsertFirst(T) public T InsertFirst(T nodeId) Parameters nodeId T Returns T InsertLast(T) public T InsertLast(T curId) Parameters curId T Returns T InsertNew(T) public T InsertNew(T leftId) Parameters leftId T Returns T InsertNewFirst() public T InsertNewFirst() Returns T InsertNewLast() public T InsertNewLast() Returns T Next(T) public T Next(T id) Parameters id T Returns T Previous(T) public T Previous(T id) Parameters id T Returns T Remove(T) public void Remove(T id) Parameters id T Walk(Func<T, bool>) public int Walk(Func<T, bool> action) Parameters action Func<T, bool> Returns int"
  },
  "api/Tomate.UnmanagedDataStore.Handle-1.html": {
    "href": "api/Tomate.UnmanagedDataStore.Handle-1.html",
    "title": "Struct UnmanagedDataStore.Handle<T> | Tomate",
    "keywords": "Struct UnmanagedDataStore.Handle<T> Namespace Tomate Assembly Tomate.dll Handle to an instance stored in the store [PublicAPI] public readonly struct UnmanagedDataStore.Handle<T> where T : unmanaged, IUnmanagedCollection Type Parameters T Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This is the generic version of UnmanagedDataStore.Handle, there is no difference between the two, the generic version allows type inference when calling Get<T>(Handle<T>), which is more convenient. But if you need to store many handles of different types in a collection, you may want to use UnmanagedDataStore.Handle. Properties IsDefault public bool IsDefault { get; } Property Value bool Operators implicit operator Handle<T>(Handle) public static implicit operator UnmanagedDataStore.Handle<T>(UnmanagedDataStore.Handle h) Parameters h UnmanagedDataStore.Handle Returns UnmanagedDataStore.Handle<T> implicit operator Handle(Handle<T>) public static implicit operator UnmanagedDataStore.Handle(UnmanagedDataStore.Handle<T> h) Parameters h UnmanagedDataStore.Handle<T> Returns UnmanagedDataStore.Handle"
  },
  "api/Tomate.UnmanagedDataStore.Handle.html": {
    "href": "api/Tomate.UnmanagedDataStore.Handle.html",
    "title": "Struct UnmanagedDataStore.Handle | Tomate",
    "keywords": "Struct UnmanagedDataStore.Handle Namespace Tomate Assembly Tomate.dll Handle to an instance stored in the store [PublicAPI] public readonly struct UnmanagedDataStore.Handle Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This is the non-generic version of UnmanagedDataStore.Handle<T>, there is no difference between the two, the generic version allows type inference when calling Get<T>(Handle<T>), which is more convenient. But if you need to store many handles of different types in a collection, you may want to use this version. Properties IsDefault public bool IsDefault { get; } Property Value bool"
  },
  "api/Tomate.UnmanagedDataStore.html": {
    "href": "api/Tomate.UnmanagedDataStore.html",
    "title": "Struct UnmanagedDataStore | Tomate",
    "keywords": "Struct UnmanagedDataStore Namespace Tomate Assembly Tomate.dll The UnmanagedDataStore allows to store Unmanaged collections through an undetermined period of time and/or shared users. [PublicAPI] public struct UnmanagedDataStore : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Read the overview documentation to get a better understanding of how fits the store in the whole picture. Each IMemoryManager implementation has a store, you may also want to create your own store based on your criteria. Design and implementation notes: The mission of the store is to store the Unmanaged Collection instances in a memory space that allows the user to access them as a ref of T. Each instance is identified by a handle, which is guaranteed to know if the instance it points to is still valid or not. Implementation wise: The handle is composed of 4 parts: the index of the entry, the generation of the entry, the type of the entry and where it is stored. The type is registered in the InternalTypeManager type, each type has an unmanaged size which determine in which level it will be stored. There are 8 levels of storage, each level has a different size of entry, starting at 16 bytes and incrementing by 16 bytes. Each unmanaged collection use a predetermined level of storage, based on its size, which is given by the InternalTypeManager. Each level has a ConcurrentBitmapL4 that tracks which entry is used or not, storage of instances is using a page approach, each page being able to store x instances, we add a new page when the current ones are full. There is a limit of pages per level, which is determined at the construction of the store. It is important to note that different types can use the same storage level, so they share the limit, you are not guaranteed to have a fixed limit of x instance for a given unmanaged collection. Properties IsDefault Returns true if the instance is a default (or disposed, there's no distinction) one, false if it's a valid one. public bool IsDefault { get; } Property Value bool IsDisposed Returns true if the instance is disposed (or default, there's no distinction), false if it's a valid one. public bool IsDisposed { get; } Property Value bool Methods ComputeStorageSize(IPageAllocator, int) Compute the size and requirement to create an instance of a store. public static (int requiredSize, (int PageCount, int EntryCountPerPage)[] pageCountPerLevel) ComputeStorageSize(IPageAllocator allocator, int maxEntryCountPerLevel) Parameters allocator IPageAllocator The allocator that will be used to store the store's own internal data. Collections stored in the store can use another one maxEntryCountPerLevel int The desired maximum of entries that can be allocated for each store level, see remarks. Returns (int requiredSize, (int PageCount, int EntryCountPerPage)[] pageCountPerLevel) A tuple where the first item is the size of the MemorySegment to use for the store allocation itself, the second item contains the information to pass during the store's construction. Remarks The store is used to store different type of Unmanaged Collection, each type (an instance of the struct itself) has a specific size, the store will identify which store level to use based on this size. There are 8 predefined levels, each level has a different size of entry, starting at 16 bytes and incremented by 16 bytes for the next level. maxEntryCountPerLevel defines the maximum number of entries that can be stored in a specific level. Beware that multiple types will have their instance stored in the same level, so this limit is shared between them. Create(IPageAllocator, MemorySegment, (int pageCount, int entryCountPerPage)[]) Create a new instance of the store. public static UnmanagedDataStore Create(IPageAllocator pageAllocator, MemorySegment dataStoreRoot, (int pageCount, int entryCountPerPage)[] pageCountPerLevel) Parameters pageAllocator IPageAllocator The allocator that will be used to allocated internal data structures that will hold the instances. Must be the same allocator used when calling ComputeStorageSize(IPageAllocator, int). dataStoreRoot MemorySegment The data segment store the store, its size is the first item of the tuple returned by ComputeStorageSize(IPageAllocator, int) pageCountPerLevel (int pageCount, int entryCountPerPage)[] The internal specification of each level to allocate, this is the second item of the tuple returned by ComputeStorageSize(IPageAllocator, int) Returns UnmanagedDataStore The store Dispose() Dispose the store and free all the resources. public void Dispose() Remarks The instances stored are disposed and will be freed if there's no other reference to them. GetMaxEntryCount<T>() Retrieve the maximum instance count that can be stored for the given type public int GetMaxEntryCount<T>() where T : unmanaged, IUnmanagedCollection Returns int The maximum number, see remarks. Type Parameters T The type Remarks Several type (generic and specified or not) may share the same storage level, so the limit returned is shared between them. Get<T>(Handle) Retrieve and instance from its handle (typeless version). public ref T Get<T>(UnmanagedDataStore.Handle handle) where T : unmanaged, IUnmanagedCollection Parameters handle UnmanagedDataStore.Handle The typeless version of the handle used to access the instance Returns T A reference to the Unmanaged Collection or a null ref if the handle is no longer valid, use IsNullRef<T>(ref readonly T) to determine it. Type Parameters T The type of the instance to retrive Remarks The UnmanagedDataStore.Handle version of this method is dealing with a typeless handle, which might be easier in some cases to store beforehand. Relying on Get<T>(Handle<T>) has the same effect, depending on your needs, it may be more convenient to rely on the typeless version or generic version of the Handle type. Get<T>(Handle<T>) Retrieve and instance from its handle. public ref T Get<T>(UnmanagedDataStore.Handle<T> handle) where T : unmanaged, IUnmanagedCollection Parameters handle UnmanagedDataStore.Handle<T> The handle of the instance to retrieve Returns T A reference to the Unmanaged Collection or a null ref if the handle is no longer valid, use IsNullRef<T>(ref readonly T) to determine it. Type Parameters T The type of the Unmanaged Collection to retrieve Remarks The UnmanagedDataStore.Handle<T> version of this method is for convenience, it infers the type of the instance to retrieve from the handle. Relying on Get<T>(Handle) has the same effect, depending on your needs, it may be more convenient to rely on the typeless version or generic version of the Handle type. Map(IPageAllocator, MemorySegment) Map an existing instance of the store. public static UnmanagedDataStore Map(IPageAllocator pageAllocator, MemorySegment dataStoreRoot) Parameters pageAllocator IPageAllocator The allocator that is storing the store's internal data dataStoreRoot MemorySegment The memory segment containing the store root data (dataStoreRoot of Create(IPageAllocator, MemorySegment, (int pageCount, int entryCountPerPage)[])). Returns UnmanagedDataStore Remove<T>(Handle<T>) Remove an instance from the store. public bool Remove<T>(UnmanagedDataStore.Handle<T> handle) where T : unmanaged, IUnmanagedCollection Parameters handle UnmanagedDataStore.Handle<T> The handle of the instance to remove. Returns bool Returns true if the instance was removed successfully and also disposed. Will return false is the instance was successfully removed from the store but still lives (because its ReferenceCounter was not 1). Type Parameters T The type of the instance to remove Exceptions InvalidHandleException is thrown if the handle no longer points to a valid instance in the store. Store<T>(ref T) Store an instance of an unmanaged collection in the store. public UnmanagedDataStore.Handle<T> Store<T>(ref T instance) where T : unmanaged, IUnmanagedCollection Parameters instance T The instance to store, see remarks. Returns UnmanagedDataStore.Handle<T> The handle pointing to the stored instance Type Parameters T The type of the instance. Remarks It's critical to understand that the struct instance will be copied (duplicated) to the store, you should no longer use instance after this call. This operation will call AddRef() on the instance to extend the lifetime, a corresponding Dispose() will be called during Remove<T>(Handle<T>). The lifetime of instance is not affected by this call. You can retrieve the instance back by calling Get<T>(Handle<T>) with the handle returned by this call."
  },
  "api/Tomate.UnmanagedDictionary-2.Enumerator.html": {
    "href": "api/Tomate.UnmanagedDictionary-2.Enumerator.html",
    "title": "Struct UnmanagedDictionary<TKey, TValue>.Enumerator | Tomate",
    "keywords": "Struct UnmanagedDictionary<TKey, TValue>.Enumerator Namespace Tomate Assembly Tomate.dll [PublicAPI] public ref struct UnmanagedDictionary<TKey, TValue>.Enumerator Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Current public UnmanagedDictionary<TKey, TValue>.KeyValuePair Current { get; } Property Value UnmanagedDictionary<TKey, TValue>.KeyValuePair Methods MoveNext() public bool MoveNext() Returns bool"
  },
  "api/Tomate.UnmanagedDictionary-2.KeyValuePair.html": {
    "href": "api/Tomate.UnmanagedDictionary-2.KeyValuePair.html",
    "title": "Struct UnmanagedDictionary<TKey, TValue>.KeyValuePair | Tomate",
    "keywords": "Struct UnmanagedDictionary<TKey, TValue>.KeyValuePair Namespace Tomate Assembly Tomate.dll public struct UnmanagedDictionary<TKey, TValue>.KeyValuePair Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Fields Key public readonly TKey Key Field Value TKey Value public TValue Value Field Value TValue"
  },
  "api/Tomate.UnmanagedDictionary-2.html": {
    "href": "api/Tomate.UnmanagedDictionary-2.html",
    "title": "Struct UnmanagedDictionary<TKey, TValue> | Tomate",
    "keywords": "Struct UnmanagedDictionary<TKey, TValue> Namespace Tomate Assembly Tomate.dll An unmanaged implementation of a dictionary [PublicAPI] public struct UnmanagedDictionary<TKey, TValue> : IUnmanagedCollection, IRefCounted, IDisposable where TKey : unmanaged where TValue : unmanaged Type Parameters TKey Type of the key TValue Type of the value Implements IUnmanagedCollection IRefCounted IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This implementation is a big copy/paste of the .net Dictionary{TKey, TValue} class and adapted to this usage. This type is MemoryMappedFile friendly, meaning you can allocate instances of this type with an MemoryManagerOverMMF as memory manager. This type can't store custom comparer in order to be unmanaged, some APIs will use the default one (like the Subscript operator), other will take one as an argument (like the TryGetValue(TKey, out bool, IEqualityComparer<TKey>) method). Constructors UnmanagedDictionary() public UnmanagedDictionary() UnmanagedDictionary(IMemoryManager, int) public UnmanagedDictionary(IMemoryManager owner, int capacity) Parameters owner IMemoryManager capacity int Properties Count Get the item count public int Count { get; } Property Value int The number of items in the list or -1 if the instance is invalid. IsDefault Check if the instance is the default (not constructed) one public bool IsDefault { get; } Property Value bool Remarks A default instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. IsDisposed Check if the instance is disposed public bool IsDisposed { get; } Property Value bool Remarks A disposed instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. this[TKey] Get/Set the value for the given key public ref TValue this[TKey key] { get; } Parameters key TKey The key to look for or set Property Value TValue Remarks If the key doesn't exist, the getter will throw an exception, the setter will add a new entry. It also will rely on the default comparer, if you need to use a custom one, you should use the TryGetValue(TKey, out bool, IEqualityComparer<TKey>) and TrySetValue(TKey, TValue, IEqualityComparer<TKey>). MemoryBlock public MemoryBlock MemoryBlock { get; } Property Value MemoryBlock MemoryManager public IMemoryManager MemoryManager { get; } Property Value IMemoryManager RefCounter public int RefCounter { get; } Property Value int Methods Add(TKey, TValue, IEqualityComparer<TKey>) Add a new entry to the dictionary given the key and its corresponding value public void Add(TKey key, TValue value, IEqualityComparer<TKey> comparer = null) Parameters key TKey The key of the entry must be unique, will throw if it already exists value TValue comparer IEqualityComparer<TKey> Exceptions ArgumentException If key is already present in the dictionary AddRef() public int AddRef() Returns int Create(IMemoryManager, int) Create a new instance public static UnmanagedDictionary<TKey, TValue> Create(IMemoryManager memoryManager = null, int capacity = 11) Parameters memoryManager IMemoryManager The memory manager to use, if null, the global one will be used (see GlobalInstance) capacity int The initial capacity Returns UnmanagedDictionary<TKey, TValue> The created instance Dispose() Dispose the instance, see remarks public void Dispose() Remarks This call will decrement the reference counter by 1 and the instance will effectively be disposed if it reaches 0, otherwise it will still be usable. EnsureCapacity(int) Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage public int EnsureCapacity(int capacity) Parameters capacity int Returns int GetEnumerator() Enumerator access for foreach public UnmanagedDictionary<TKey, TValue>.Enumerator GetEnumerator() Returns UnmanagedDictionary<TKey, TValue>.Enumerator The enumerator, an instance of the UnmanagedDictionary<TKey, TValue>.Enumerator type Remarks BEWARE: the enumerator will rely on the default comparer. GetOrAdd(TKey, out bool, IEqualityComparer<TKey>) Get the value for the given key or add a new entry if it doesn't exist public ref TValue GetOrAdd(TKey key, out bool found, IEqualityComparer<TKey> comparer = null) Parameters key TKey The key of the element to get or add found bool If true the element with this key already exists. If false there was no element for the given key and we've added one. comparer IEqualityComparer<TKey> The comparer to use with this operation, null will be the default one Returns TValue The value of the element corresponding to the given key RefreshFromMMF(MemoryBlock) public void RefreshFromMMF(MemoryBlock newData) Parameters newData MemoryBlock Remove(TKey, out TValue, IEqualityComparer<TKey>) Remove the entry of the given key from the dictionary public bool Remove(TKey key, out TValue value, IEqualityComparer<TKey> comparer = null) Parameters key TKey The key of the entry to remove value TValue If the entry was successfully removed, will contain the corresponding value, otherwise will contain default. comparer IEqualityComparer<TKey> The comparer to use with this operation, null will be the default one Returns bool TryAdd(TKey, TValue, IEqualityComparer<TKey>) Try to add a new entry, if the key already exists, the operation will return false public bool TryAdd(TKey key, TValue value, IEqualityComparer<TKey> comparer = null) Parameters key TKey The key of the entry to add value TValue The corresponding value comparer IEqualityComparer<TKey> The comparer to use with this operation, null will be the default one Returns bool Returns true is the entry was successfully added, false if we couldn't add it because there's already another with the same key TryGetValue(TKey, out bool, IEqualityComparer<TKey>) Try to get the value corresponding to the given key public ref TValue TryGetValue(TKey key, out bool found, IEqualityComparer<TKey> comparer = null) Parameters key TKey The key of the element to access its value from. found bool comparer IEqualityComparer<TKey> The comparer to use with this operation, null will be the default one Returns TValue Will return true if the element was found, false otherwise. TrySetValue(TKey, TValue, IEqualityComparer<TKey>) Add/set a entry in the dictionary public bool TrySetValue(TKey key, TValue value, IEqualityComparer<TKey> comparer = null) Parameters key TKey The key of the entry to add or change value TValue The value to add/set comparer IEqualityComparer<TKey> The comparer to use with this operation, null will be the default one Returns bool Returns false if a new entry was added, true if an existing one was modified with the new give value."
  },
  "api/Tomate.UnmanagedList-1.Enumerator.html": {
    "href": "api/Tomate.UnmanagedList-1.Enumerator.html",
    "title": "Struct UnmanagedList<T>.Enumerator | Tomate",
    "keywords": "Struct UnmanagedList<T>.Enumerator Namespace Tomate Assembly Tomate.dll public ref struct UnmanagedList<T>.Enumerator Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Enumerator(UnmanagedList<T>) public Enumerator(UnmanagedList<T> owner) Parameters owner UnmanagedList<T> Properties Current public ref T Current { get; } Property Value T Methods MoveNext() public bool MoveNext() Returns bool"
  },
  "api/Tomate.UnmanagedList-1.html": {
    "href": "api/Tomate.UnmanagedList-1.html",
    "title": "Struct UnmanagedList<T> | Tomate",
    "keywords": "Struct UnmanagedList<T> Namespace Tomate Assembly Tomate.dll An unmanaged list of unmanaged items [PublicAPI] public struct UnmanagedList<T> : IUnmanagedCollection, IRefCounted, IDisposable where T : unmanaged Type Parameters T The type of items to store Implements IUnmanagedCollection IRefCounted IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks Be sure to read the overview documentation to learn how to use this type. This type is MemoryMappedFile friendly, meaning you can allocate instances of this type with an MemoryManagerOverMMF as memory manager. Constructors UnmanagedList() Create an instance with the GlobalInstance. public UnmanagedList() UnmanagedList(IMemoryManager, int) Create an instance of the UnmanagedList public UnmanagedList(IMemoryManager memoryManager = null, int initialCapacity = 4) Parameters memoryManager IMemoryManager The Memory Manager to use, if null the GlobalInstance will be used. initialCapacity int Initial capacity of the list, the number of items it can hold without resizing. Properties Capacity Get/set the capacity of the list public int Capacity { get; set; } Property Value int Remarks Get accessor will return -1 if the list is disposed/default. Set accessor will throw an exception if the new capacity is less than the actual count. Content Get a MemorySegment of the content of the list public MemorySegment<T> Content { get; } Property Value MemorySegment<T> Remarks This API will only assert in debug mode if you attempt to access the content of an uninitialized instance. BEWARE: the segment may no longer be valid if you perform an operation that will resize the list. Count Get the item count public int Count { get; } Property Value int The number of items in the list or -1 if the instance is invalid. IsDefault Check if the instance is the default (not constructed) one public bool IsDefault { get; } Property Value bool Remarks A default instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. IsDisposed Check if the instance is disposed public bool IsDisposed { get; } Property Value bool Remarks A disposed instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. this[int] Subscript operator for random access to an item in the list public ref T this[int index] { get; } Parameters index int The index of the item to retrieve, must be within the range of [0..Count-1] Property Value T Remarks This API checks for the bounds and throws the index is incorrect. Will throw InvalidObjectException if the instance is default or disposed. MemoryBlock Access to the underlying MemoryBlock of the list, use with caution public MemoryBlock MemoryBlock { get; } Property Value MemoryBlock MemoryManager Access to the MemoryManager used by the list to allocate its content public IMemoryManager MemoryManager { get; } Property Value IMemoryManager RefCounter Get the reference counter of the instance, will return -1 if the instance is default/disposed public int RefCounter { get; } Property Value int Methods Add(T) Add an item to the list public int Add(T item) Parameters item T The item to add Returns int The index of the added item Remarks Will throw InvalidObjectException if the instance is default or disposed. AddInPlace() Return the ref of the added element, beware, read remarks public ref T AddInPlace() Returns T The reference to the added element. Remarks You must be sure any other operation on this list won't trigger a resize of its content for the time you use the ref. Otherwise the ref will point to a incorrect address and corruption will most likely to occur. Use this API with great caution. Will throw InvalidObjectException if the instance is default or disposed. AddRef() Add a reference to the instance public int AddRef() Returns int The new value of the reference counter Remarks A matching call to Dispose() will have to be made to release the reference. Clear() Clear the content of the list public void Clear() CopyTo(T[], int) Copy the content of the list to an array, starting at the given index public void CopyTo(T[] items, int i) Parameters items T[] The array that will receive the list's items i int The index in the array to copy the first element Remarks Will throw is the array's portion (delimited by and its length) is too small to contain all the items. CreateInStore(IMemoryManager, int, out Handle<UnmanagedList<T>>) public static ref UnmanagedList<T> CreateInStore(IMemoryManager memoryManager, int initialCapacity, out UnmanagedDataStore.Handle<UnmanagedList<T>> handle) Parameters memoryManager IMemoryManager initialCapacity int handle UnmanagedDataStore.Handle<UnmanagedList<T>> Returns UnmanagedList<T> CreateInStore(IMemoryManager, UnmanagedDataStore, int, out Handle<UnmanagedList<T>>) public static ref UnmanagedList<T> CreateInStore(IMemoryManager memoryManager, UnmanagedDataStore store, int initialCapacity, out UnmanagedDataStore.Handle<UnmanagedList<T>> handle) Parameters memoryManager IMemoryManager store UnmanagedDataStore initialCapacity int handle UnmanagedDataStore.Handle<UnmanagedList<T>> Returns UnmanagedList<T> Dispose() Dispose the instance, see remarks public void Dispose() Remarks This call will decrement the reference counter by 1 and the instance will effectively be disposed if it reaches 0, otherwise it will still be usable. GetEnumerator() Enumerator access for foreach public UnmanagedList<T>.Enumerator GetEnumerator() Returns UnmanagedList<T>.Enumerator The enumerator, an instance of the UnmanagedList<T>.Enumerator type GetFromStore(IMemoryManager, Handle<UnmanagedList<T>>) public static ref UnmanagedList<T> GetFromStore(IMemoryManager memoryManager, UnmanagedDataStore.Handle<UnmanagedList<T>> handle) Parameters memoryManager IMemoryManager handle UnmanagedDataStore.Handle<UnmanagedList<T>> Returns UnmanagedList<T> IndexOf(T) Return the index of the given item in the list public int IndexOf(T item) Parameters item T The item to look for. Returns int The index or -1 if there's no such item Remarks Will throw InvalidObjectException if the instance is default or disposed. Insert(int, T) Inserts an element into this list at a given index. The size of the list is increased by one. If required, the capacity of the list is doubled before inserting the new element. public void Insert(int index, T item) Parameters index int The index of the position to insert the given item item T The item to insert Remarks Will throw InvalidObjectException if the instance is default or disposed. MoveToStore(IMemoryManager, out Handle<UnmanagedList<T>>) public ref UnmanagedList<T> MoveToStore(IMemoryManager memoryManager, out UnmanagedDataStore.Handle<UnmanagedList<T>> handle) Parameters memoryManager IMemoryManager handle UnmanagedDataStore.Handle<UnmanagedList<T>> Returns UnmanagedList<T> RefreshFromMMF(MemoryBlock) public void RefreshFromMMF(MemoryBlock newData) Parameters newData MemoryBlock Remove(T) Remove the given item from the list public bool Remove(T item) Parameters item T The item to remove Returns bool true if there was such item, false if we couldn't find anything to remove Remarks Remove will only remove the first occurrence of the item in the list, the whole content succeeding the item will be shifted to fill the gap. Will throw InvalidObjectException if the instance is default or disposed. RemoveAt(int) Remove the item at the given index public void RemoveAt(int index) Parameters index int The index to remove the item at, must be a valid range or IndexOutOfRangeException will be thrown Remarks Will throw InvalidObjectException if the instance is default or disposed."
  },
  "api/Tomate.UnmanagedQueue-1.html": {
    "href": "api/Tomate.UnmanagedQueue-1.html",
    "title": "Struct UnmanagedQueue<T> | Tomate",
    "keywords": "Struct UnmanagedQueue<T> Namespace Tomate Assembly Tomate.dll A queue containing unmanaged items with (ref) access to each of them [PublicAPI] public struct UnmanagedQueue<T> : IUnmanagedCollection, IRefCounted, IDisposable where T : unmanaged Type Parameters T Implements IUnmanagedCollection IRefCounted IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This class is heavily based from the Queue<T> type of the .net framework. Designed for single thread usage only. TryPeek(ref T) and Peek() return ref of {T} , so don't use this reference after a Enqueue() or Dequeue() operation. Constructors UnmanagedQueue() Construct an instance with the default memory manager (GlobalInstance) and the default capacity. public UnmanagedQueue() UnmanagedQueue(IMemoryManager, int) Construct an instance with the given memory manager and capacity. public UnmanagedQueue(IMemoryManager memoryManager = null, int capacity = 8) Parameters memoryManager IMemoryManager Memory manager to use capacity int Initial capacity Properties Capacity Get/set the capacity of the queue public int Capacity { get; set; } Property Value int Remarks Get accessor will return -1 if the queue is disposed/default. Set accessor will throw an exception if the new capacity is less than the actual count. Count Get the item count public int Count { get; } Property Value int The number of items in the queue or -1 if the instance is invalid. IsDefault Check if the instance is the default (not constructed) one public bool IsDefault { get; } Property Value bool Remarks A default instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. IsDisposed Check if the instance is disposed public bool IsDisposed { get; } Property Value bool Remarks A disposed instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. this[int] Subscript operator for random access to an item in the queue public ref T this[int index] { get; } Parameters index int The index of the item to retrieve, must be within the range of [0..Count-1] Property Value T Remarks This API checks for the bounds and throws the index is incorrect. Will throw InvalidObjectException if the instance is default or disposed. MemoryBlock Access to the underlying MemoryBlock of the queue, use with caution public MemoryBlock MemoryBlock { get; } Property Value MemoryBlock MemoryManager Access to the MemoryManager used by the queue to allocate its content public IMemoryManager MemoryManager { get; } Property Value IMemoryManager RefCounter Get the reference counter of the instance, will return -1 if the instance is default/disposed public int RefCounter { get; } Property Value int Methods AddRef() public int AddRef() Returns int Clear() Clear the content of the queue public void Clear() Dequeue() Removes the object at the head of the queue and returns it. public ref T Dequeue() Returns T A reference to the item that was dequeued, don't use this reference after a Queue<T> operation as it may induce a resize of the internal buffer. Remarks If the queue is empty, this method throws an InvalidOperationException. Dispose() Dispose the instance, see remarks public void Dispose() Remarks This call will decrement the reference counter by 1 and the instance will effectively be disposed if it reaches 0, otherwise it will still be usable. Enqueue() Enqueue and return a reference to the new item public ref T Enqueue() Returns T This method allocates the item in the queue and return a reference to it, it's up to the caller to set the value of the item. Don't keep the reference more than what is strictly necessary because it can be invalidated by operations that resize the content of the queue. Enqueue(T) Enqueue an item in the queue public void Enqueue(T item) Parameters item T The item to enqueue Remarks This method is safer than Enqueue(). Enqueue(ref T) Enqueue an item in the queue public void Enqueue(ref T item) Parameters item T A reference to the item to enqueue, which is preferred from the non-reference version if your struct is big. Remarks This method is safer than Enqueue(). Peek() Peek the item at the head of the queue public ref T Peek() Returns T A reference to the item, will throw if the queue is empty. RefreshFromMMF(MemoryBlock) public void RefreshFromMMF(MemoryBlock newData) Parameters newData MemoryBlock ToArray() public T[] ToArray() Returns T[] TryDequeue(out T) Attempt to dequeue an item from the queue public bool TryDequeue(out T result) Parameters result T The dequeued item Returns bool Returns true if the queue was not empty and an item was dequeued and returned, false otherwise. TryPeek(ref T) Attempt to peek an item from the queue public bool TryPeek(ref T result) Parameters result T A reference that will contain the item at the head of the queue. Returns bool true if there was an item, false if the queue was empty."
  },
  "api/Tomate.UnmanagedStack-1.html": {
    "href": "api/Tomate.UnmanagedStack-1.html",
    "title": "Struct UnmanagedStack<T> | Tomate",
    "keywords": "Struct UnmanagedStack<T> Namespace Tomate Assembly Tomate.dll A stack containing unmanaged items with ref access to each of them [PublicAPI] public struct UnmanagedStack<T> : IUnmanagedCollection, IRefCounted, IDisposable where T : unmanaged Type Parameters T Implements IUnmanagedCollection IRefCounted IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Remarks This class is heavily based from the Stack<T> type of the .net framework. Designed for single thread usage only. TryPeek(ref T) and Peek() return ref of {T} , so don't use this reference after a Push(ref T) or Pop() operation. Constructors UnmanagedStack() Construct an instance with the default memory manager (GlobalInstance) and the default capacity. public UnmanagedStack() UnmanagedStack(IMemoryManager, int) Construct an instance with the given memory manager and capacity. public UnmanagedStack(IMemoryManager memoryManager = null, int capacity = 8) Parameters memoryManager IMemoryManager Memory manager to use capacity int Initial capacity Properties Capacity Get/set the capacity of the stack public int Capacity { get; set; } Property Value int Remarks Get accessor will return -1 if the stack is disposed/default. Set accessor will throw an exception if the new capacity is less than the actual count. Content Get a MemorySegment of the content of the stack public MemorySegment<T> Content { get; } Property Value MemorySegment<T> Remarks This API will only assert in debug mode if you attempt to access the content of an uninitialized instance. BEWARE: the segment may no longer be valid if you perform an operation that will resize the list. Count Get the item count public int Count { get; } Property Value int The number of items in the stack or -1 if the instance is invalid. IsDefault Check if the instance is the default (not constructed) one public bool IsDefault { get; } Property Value bool Remarks A default instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. IsDisposed Check if the instance is disposed public bool IsDisposed { get; } Property Value bool Remarks A disposed instance can't be used, some APIs will assert in debug mode and crash in release mode, others will throw an exception or return -1. There is no distinction between a default instance and a disposed one. this[int] Subscript operator for random access to an item in the stack public ref T this[int index] { get; } Parameters index int The index of the item to retrieve, must be within the range of [0..Length-1] Property Value T Remarks This API checks for the bounds and throws the index is incorrect. Will throw InvalidObjectException if the instance is default or disposed. MemoryBlock Access to the underlying MemoryBlock of the list, use with caution public MemoryBlock MemoryBlock { get; } Property Value MemoryBlock MemoryManager Access to the MemoryManager used by the list to allocate its content public IMemoryManager MemoryManager { get; } Property Value IMemoryManager RefCounter Get the reference counter of the instance, will return -1 if the instance is default/disposed public int RefCounter { get; } Property Value int Methods AddRef() public int AddRef() Returns int Clear() Clear the content of the list public void Clear() Dispose() Dispose the instance, see remarks public void Dispose() Remarks This call will decrement the reference counter by 1 and the instance will effectively be disposed if it reaches 0, otherwise it will still be usable. Peek() Peek the item at the top of the stack public ref T Peek() Returns T A reference to the item, will throw if the stack is empty. Pop() Returns the top object on the stack without removing it. If the stack is empty, Peek throws an InvalidOperationException. public ref T Pop() Returns T Push() Push and return a reference to the new item public ref T Push() Returns T This method allocates the item in the stack and return a reference to it, it's up to the caller to set the value of the item. Don't keep the reference more than what is strictly necessary because it can be invalidated by operations that resize the content of the stack. Push(T) Push an item in the stack public void Push(T item) Parameters item T The item to stack up Push(ref T) Push an item on the top of the stack public void Push(ref T item) Parameters item T A reference to the item to push, which is preferred from the non-reference version if your struct is big. RefreshFromMMF(MemoryBlock) public void RefreshFromMMF(MemoryBlock newData) Parameters newData MemoryBlock ToArray() public T[] ToArray() Returns T[] TryPeek(ref T) Attempt to peek an item from the stack public bool TryPeek(ref T result) Parameters result T A reference that will contain the item at the top of the stack. Returns bool true if there was an item, false if the stack was empty. TryPop(out T) Try to pop an item from the stack public bool TryPop(out T result) Parameters result T If the stack was not empty, the item will be stored in the parameter upon return of the call Returns bool true if an item was popped, false if the stack was empty"
  },
  "api/Tomate.WindowsProcessProvider.html": {
    "href": "api/Tomate.WindowsProcessProvider.html",
    "title": "Class WindowsProcessProvider | Tomate",
    "keywords": "Class WindowsProcessProvider Namespace Tomate Assembly Tomate.dll public class WindowsProcessProvider : IProcessProvider Inheritance object WindowsProcessProvider Implements IProcessProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DisposeExtensions.DisposeAndNull<T>(object, ref T) Properties CurrentProcessId public int CurrentProcessId { get; } Property Value int Methods IsProcessAlive(int) public bool IsProcessAlive(int processId) Parameters processId int Returns bool"
  },
  "api/Tomate.html": {
    "href": "api/Tomate.html",
    "title": "Namespace Tomate | Tomate",
    "keywords": "Namespace Tomate Classes AlignmentExtensions BitMapHelpers BlockOverrunException BlockReferential Static class that references all the IBlockAllocator to ensure a generic free of any allocated MemoryBlock. CapacityTooBigException ConcurrentBitmapL3All Concurrent storage of a BitMap with three levels (two of aggregation) for efficient looking for empty bit. DefaultMemoryManager General purpose Memory Manager DisposeExtensions InvalidAllocationSizeException InvalidHandleException InvalidObjectException ItemMaxCapacityReachedException ItemSetTooBigException MathExtensions MemoryManager Allow to allocate segments of memory MemoryManagerOverMMF MemoryManagerOverMMFCreateException MiscExtensions MockProcessProvider MurmurHash2 PackExtensions PaddingExtensions PageAllocator QuickRand Quick random generation number SegmentConstructException SmallLockConcurrencyExceededException Exception triggered when an operation can't be performed to due a greater number of concurrent operations than SmallLock can handle. StoreInExtensions WindowsProcessProvider Structs AccessControl Synchronization type that allows multiple concurrent shared access or one exclusive. Doesn't allow re-entrant calls, burn CPU cycle on wait, using SpinWait Costs 8 bytes of data. BlockReferential.GenBlockHeader Each MemoryBlock allocated through a IMemoryManager based allocator must contain this header BEFORE the block's starting address. BurnBabyBurn Put the calling thread in hold for a given time span ConcurrentBitmapL4 This type allows to Allocate/Free bits in a bitmap in a concurrent friendly and scalable fashion. It is possible to allocate from 1 to 64 consecutive bits. ExclusiveAccessControl Simple access control supporting a single process and only exclusive access LogicalMemorySegment Stores the location and size of a logical memory segment MappedAppendCollection<T> Append-only collection on a Page Allocator MappedBlockingSimpleDictionary<TKey, TValue> Fixed size, not efficient dictionary, with concurrent operations made through a lock MappedBlockingSimpleDictionary<TKey, TValue>.Enumerator Enumerates the elements of the dictionary. MappedBlockingSimpleDictionary<TKey, TValue>.KeyValuePair Store an item MappedConcurrentChunkBasedCircularBuffer MappedConcurrentChunkBasedQueue MappedConcurrentChunkBasedQueue.DequeueHandle Dequeue handle used to access the dequeued chunk's type and data MappedConcurrentChunkBasedQueue.EnqueueHandle<T> Enqueue handle used to set the queued chunk's data MappedExclusiveAccessControl Access control supporting multiple processes and only exclusive access MappedStringTable MemoryBlock Represent an allocated block of unmanaged memory MemoryBlock<T> MemoryManager.ScopedMemorySegment MemoryManagerOverMMF.CreateSettings MemoryManagerOverMMF.SegmentHeader MemoryManagerOverMMF.TwoWaysLinkedList MemoryManagerOverMMF.TwoWaysLinkedList.Link MemorySegment Define a memory segment stored at a fixed address MemorySegment<T> Define a memory segment stored at a fixed address, generic version MemorySegment<T>.Enumerator Enumerates the elements of a MemorySegment<T>. MemorySegments<T1, T2> MemorySegments<T1, T2, T3> MemorySegments<T1, T2, T3, T4> MemorySegments<T1, T2, T3, T4, T5> MemoryView<T> ProfileThis ProfileThis.Handle RewriteMemoryView Rewrite the content of the view by processing its data SmallLock An interprocess lock allowing control over concurrent accesses for a given (immaterial) resource. String256 Stores a string using UTF8 format with a max size of 256-bytes. String64 Stores a string using UTF8 format with a max size of 64-bytes. TimeSegment TwoWaysLinkedList<T> TwoWaysLinkedList<T>.Link UnmanagedDataStore The UnmanagedDataStore allows to store Unmanaged collections through an undetermined period of time and/or shared users. UnmanagedDataStore.Handle Handle to an instance stored in the store UnmanagedDataStore.Handle<T> Handle to an instance stored in the store UnmanagedDictionary<TKey, TValue> An unmanaged implementation of a dictionary UnmanagedDictionary<TKey, TValue>.Enumerator UnmanagedDictionary<TKey, TValue>.KeyValuePair UnmanagedList<T> An unmanaged list of unmanaged items UnmanagedList<T>.Enumerator UnmanagedQueue<T> A queue containing unmanaged items with (ref) access to each of them UnmanagedStack<T> A stack containing unmanaged items with ref access to each of them Interfaces IMemoryManager IPageAllocator IProcessProvider IRefCounted IUnmanagedCollection Facade for an unmanaged based instance Enums DefaultMemoryManager.DebugMemoryInit Debugging feature to initialize the MemoryBlock's content upon allocation (available in DEBUGALlOC only) Delegates BinarySearchComp<T1, T2, TResult> TwoWaysLinkedList<T>.Accessor"
  },
  "doc/bitmaps.html": {
    "href": "doc/bitmaps.html",
    "title": "Bitmaps overview | Tomate",
    "keywords": "Bitmaps overview Bitmaps are...maps of bits...you allocate a bitmap with a given capacity of n bits, then you can allocate/free bits (when the bit is 0: it's free, when it's 1: it's occupied). This allows the implementation of a occupancy map, for instance, the simpler example is the PageAllocator type. Bitmap are designed for concurrent accesses, their implementation may vary in term of what matters the most, but most of the time it is for the sake of a good balance between concurrency and allocation efficiency. You could argue they are not that friendly toward false sharing and you would be right, but synchronizing through some kind of Interlocked operation would generate contention on the whole bitmap content and wouldn't scale as well the bigger the map is. In any case, this type of resource is persistent and inter-process friendly, so it plays very well with the Memory Mapped Files. Currently, 🍅 implements the ConcurrentBitmapL3All and the ConcurrentBitmapL4 types."
  },
  "doc/collections.html": {
    "href": "doc/collections.html",
    "title": "Collections overview | Tomate",
    "keywords": "Collections overview Unmanaged* collections overview Each collection type starting with Unmanaged applies to this section, the most simple and notable one being UnmanagedList<T>. Implementation overview Unmanaged collections are struct based types that rely on a IMemoryManager to store the collection's data. Most of the time, the struct in itself stores: A MemoryBlock that points to the allocated memory segment which contains a header (e.g.: storing capacity, count) and the items stored in the collection. Other fields present to manage the collection more efficiently (cached pointers, see below). Data stored in the MemoryBlock must be process-independent, because Unmanaged Collection are designed to be used along with a MemoryManagerOverMMF which allows the collection to be stored in a Memory Mapped File and be shared between processes. So it means, no addresses, no pointers, no references, only offsets. The Unmanaged collection wraps the MemoryBlock and provides the API to interact with the data, it also contains process-dependent fields like pointer to the header, pointer to the items, etc. to boost performances of the operations. Each API call check these accelerations fields are up-to-date, and refresh them if needed. Usage overview Working with value types imposes specific constraints, the purpose of 🍅 is to make it as easy as possible for the user. Two cases are to be considered: Short-lived, single user instances Using an instance bound by a defined scope: { // Create the list instance using var myList = new UnmanagedList<int>(); // Add 10 items with values from 0 to 9 for (int i=0; i<10; i++) myList.Add(i); PrintContent(ref myList); } // myList is disposed here, the MemoryBlock allocated is released // Here the list could be passed by copy instead of by reference, it would work in this case because the list is not // mutated by this method and we know the caller doesn't too. But it's a dangerous practice and should be avoided. void PrintContent(ref UnmanagedList<int> list) { // this will print the content of the list foreach (var val in list) Console.WriteLine(val); } Bound to a custom type Using an instance as a field of a custom type: public class MyType : IDisposable { public MyType() { _myList = new UnmanagedList<int>(); } // Provide a ref access to the list, which allow the caller to mutate its content safely public ref UnmanagedList<int> List => ref _myList; public void Add(int val) { _myList.Add(val); } public void PrintContent() { foreach (var val in _myList) Console.WriteLine(val); } public void Dispose() { if (IsDisposed) return; _myList.Dispose(); _myList = default; GC.SuppressFinalize(this); } public bool IsDisposed => _myList.IsDefault; // Not mandatory, but if the user ever forget to call Dispose, the memory of the list will be released during // GC collection. // The type could also not implement IDisposable and we would only rely on the destructor to free the memory. ~MyType() { Dispose(); } private UnmanagedList<int> _myList; } Warning Note that users have access to the List through a ref property, which allows them to use the very same instance as the class itself. Again, using a copy of the list instance would work fine in very specific cases, you still \"share\" the content with the initial instance, but if one or the other instance mutates the list and that triggers a reallocation of the MemoryBlock, the other instance will be left with a corrupted instance pointing to a memory block that no longer exists and without the possibility to know it no longer does. Sharing instances through a store If you need to share an instance through multiple users for a controlled lifetime, you can use a UnmanagedDataStore. As we established the safest way to manipulate the unmanaged collections is through a ref access, there are a set of limitations arising, the main one being it's not possible to declare a ref field in a type (unless the type is a ref type itself, but the limitations are just escalated). which make it very hard to point to a given instance from multiple places. The store offers a place where the instances are stored for a lifetime you control, each instance is identified and accessed by a handle which is safe to store anywhere (even in a MemoryMappedFile). This handle also is safe to use because it knows if the instance it points to is still valid or no longer. Using a handle is lifetime safe, type safe and its size is not bigger than a 64-bit pointer. For convenience, each implementation of IMemoryManager has a corresponding store, so you can use it directly or create your own, if needed. You can also, for instance, create list of lists, for example: // Create the main list, not stored in the store for the sake of the example, but should be UnmanagedList<UnmanagedDataStore.Handle<UnmanagedList<int>>> globalList = new(); { // Create a list that will be directly stored in the store ref var childList = ref UnmanagedList<int>.CreateInStore(null, 8, out var handle); childList.Add(10); // Add the childList to the globalList globalList.Add(handle); } // ... later on { // Retrieve the childList from the globalList through the store ref var childList = ref UnmanagedList<int>.GetFromStore(null, globalList[0]); Assert.That(childList[0], Is.EqualTo(10)); } TL;DR Three levels: The plain data, stored in a MemoryBlock, that is process-independent and can be stored inside a MemoryMappedFile. The user is not supposed to interact with it directly. The Unmanaged Collection, a struct that wraps the MemoryBlock and provides the API to interact with the data. The user can interact with it in multiple ways, depending on the use case. You should always work with it through a ref access, pass it/return it as a ref. As working with ref of struct implies restrictions, you can rely on the UnmanagedDataStore to safely store, access and share instances. Lifecycle These collection have a IsDefault and IsDisposed properties for you to know if the instance is valid (IsDefault == false) or no longer usable because it's disposed (IsDisposed == true). You can also share a given instance through multiple users, each with their own lifetime by calling AddRef() to extend and a corresponding Dispose() to release usage for this particular user. Enumeration of items While these collections don't implement the IEnumerable<T> interface, enumeration of their items is still possible as you would expect because they implement the GetEnumerator() method (more details here. The enumerator also expose the item as a ref T which allows you to iterate on the actual value and not a copy of it. // Create the list instance using var myList = new UnmanagedList<int>(); // Add 10 items with values from 0 to 9 for (int i=0; i<10; i++) myList.Add(i); // this will add 100 to each item in the list as val is passed by ref foreach (ref int val in myList) val += 100; Mapped* collections overview Not written yet..."
  },
  "doc/lifetime-instances.html": {
    "href": "doc/lifetime-instances.html",
    "title": "Lifetime of unmanaged struct-based instances | Tomate",
    "keywords": "Lifetime of unmanaged struct-based instances .net features two kinds of types: classes and structs. Instances of classes (aka reference types) have their lifetime tracked by the references to each of them, the garbage collector takes care of releasing the memory of instances that are no longer reachable. It couldn't be easier for the user and it's as safe as it can be. Instances of struct (aka value types) are...different. Initially in .net a struct was only passed through method calls and/or instances' field by copy only. Things got more complex when microsoft introduced the concept of ref struct. Unmanaged struct and GC-free \"long-term\" storage Struct based types can be split into two kinds: A struct that declares some of its fields using the class type. A struct that answers to a set of criteria which makes it an unmanaged struct. Unmanaged structs are very interesting because they have absolutely no tie with the GC, and this is what 🍅 is about. Another trick is to rely on the Unsafe.AsRef (void*) API to conveniently represent an area of memory of any kind as a ref struct instance. So, it is possible in .net to allocate a big memory block (of managed memory), to pin this block (to make sure its address won't change, which is equivalent to a native memory block) and use it the way we would in C/C++. Example: var array = GC.AllocateUninitializedArray<byte>(64 * 1024 * 1024, true); var baseAddress = (byte*)Marshal.UnsafeAddrOfPinnedArrayElement(array, 0).ToPointer(); From this point, we can store any data we want in this memory block and expose its content as ref struct instances of unmanaged type. But anything has a cost, pros/cons, in our case the lifetime of things is not as safe as classic .net would be, we must make sure everything is taken care of correctly to ensure we won't access a ref struct instance of a memory block we just freed! One of the purpose of 🍅 is to ensure the lifetime is taken care of for you, with the minimal impact on the way you code. It will be more complex than classic .net programming, but performances will be better too. Reference counting to the rescue It's a popular, simple and proven mechanic that allows multiple virtual users to share the usage of a given instance. In 🍅, it is the IRefCounted interface that takes care of this. Any type implementing this interface has its lifetime controlled by a reference counter. Each logical user calls AddRef() to extend the lifetime of the instance as long as it need. Note IRefCounted derives from IDisposable, calling Dispose() acts as decrementing the reference counter, if it is reaching 0, then the instance is disposed, otherwise the instance is still alive, because still being used by others. Typical usage scenario Each instance is created by a logical user, we will call this user the owner. The owner has its own agenda concerning the lifetime of the instance, when it's done with it, Dispose() is called. In the meantime, if another logical user comes into play, for instance: User A creates instance Z. User A call a method of user B, passing Z as parameter. B needs to store Z and keep it for a indefinite amount of time. A no longer needs Z. B still is using Z. B no longer needs Z. It is crucial to understand that: In step 3, B needs to call Z.AddRef() to extend its lifetime, setting the reference counter to 2. In step 4, A will call Z.Dispose(), but Z will still exists (Z.IsDisposed is false) because it had a reference counter of 2 and Dispose() decremented down to 1. In step 6, B needs to call Z.Dispose(), which will set the reference counter to 0, which will trigger a disposing of the object (Z.IsDisposed is true). Recap of the lifetime for struct, collection, IRefCounted based types struct A struct instance's lifetime is bound by the component that stores it. So in itself there is no point to make a struct type implementing IRefCounted. Unless your struct is more a handle than storing data, which is the case for the Unmanaged* collections, the struct is simply a handle, concretely it stores a MemoryBlock that contains the actual data, and other fields specific to the implementation of the type itself. The MemoryBlock stores all the data for the collection (a header + the actual items). The IRefCounted interface of UnmanagedList<T> defers to the underlying MemoryBlock which support reference counting. TL;DR IRefCounted allows to share an instance. MemoryBlock implemented IRefCounted and can be shared. A struct's instance can't be shared, unless the instance is more a handle/facade and the data in itself is stored to a location that can be shared. Unmanaged* collections can be shared for the reason cited above (see more here) Beware of undesired copies! One could say and argue there is a design flaw in C# because it is very easy to copy an instance of a struct instead of using a reference of it. C/C++ languages have the notion of pointer (then address), which is semantically different from the instance itself. It's either your pass the instance (and it's a copy) or you pass a pointer of the instance (and you copy the pointer itself, not the instance). In C#, it's easy to do things the wrong way because you can have a method that returns a ref to struct and yet, if you don't pay attention and do the \"usual stuff\", you will end up copying this returned instance. Example: public ref UnmanagedList<int> GetList() { ref return myList; } ... // The wrong way var theList = GetList(); // here `theList`is a copy of `myList` // The right way ref var theList2 = ref GetList(); // here `theList2` is the same instance as `myList` Warning Both invocations of GetList() are compiling, and that's where things are dangerous and could be considered a design flaw. One could argue that a method doing a ref return is, by designed, expected the caller to get a reference of the returned instance and not copying it. People being working with class based instance >90% of the time and being not familiar with ref return and ref var could easily get it wrong. Note Back to our example above, if you do the first call, ending up copying the UnmanagedList, in appearances and concretely, you can use the list just fine... as long as you are not calling a method that will result in resizing the list's content (or the original owner of the list also does it). But it's clearly risky and should be avoided at all cost, but the fact that it won't lead to an unexpected behavior right way makes it very treacherous. Beware of ref access Consider this example: using var ul = new UnmanagedList<int>(); ul.Add(0); ul.Add(1); ul.Add(2); ref var i1 = ref ul[1]; // Reference to the 2dn item of the list Assert.That(i1, Is.EqualTo(1)); // So far so good ul.RemoveAt(0); // Now we remove the first element, all subsequent shift one slot to the left. Assert.That(i1, Is.EqualTo(1)); // It fails because i1 is pointing to the second location which now is 2. // 0, [1], 2 before RemoveAt(). 0, [2] after. The subscript (i.e. []) operator is really convenient in its ref return form, but you have to be aware of what it really represents and its true scope of usage. In the example above, i1 represents the 2nd location of the list, it doesn't represent the item stored at this location. Doing var it1 = ul[1] would have been getting a copy of the item. Warning A ref var is an address always, treat it as a such."
  },
  "doc/memory-management.html": {
    "href": "doc/memory-management.html",
    "title": "Memory Management Overview | Tomate",
    "keywords": "Memory Management Overview There is only one way to avoid GC in .net when you're manipulating data with a indeterminate lifecycle: a custom memory Manager. That's right, you trade ease of use against performance, which is not unusual. The responsibility of the memory lifecycle shift on your side, some features and helpers ease things for you, but still, it's your job now. Memory Manager and friends IMemoryManager Tomate declare the IMemoryManager interface which has two implementations so far: DefaultMemoryManager: which is the default memory manager for in-process memory allocation. MemoryManagerOverMMF: which is the memory manager that maps a memory-mapped-file (MMF) for interprocess communication/processing and/or persistent data storage. The purpose of a Memory Manager is to allocate, resize and free memory blocks while being thread-safe. IPageAllocator A simpler kind of allocator can be implemented through the IPageAllocator interface, it allows to allocate fixed-size memory segment. Warning Page allocators don't deal with MemoryBlock but only with MemorySegment and BlockId (which is simply an int). Memory Block The memory manager is used to allocated linear segments of memory, each one has a fixed address and is represented by the MemoryBlock type. From an instance of MemoryBlock you can: Extend the lifecycle by calling AddRef(). Resize the block, which will allocate a new one, copying the content of the existing and release it. So your instance will point to a new address. Release/Dispose the memory block. Every block stores a reference to the Memory Manager that \"owns\" it and then can be released without \"knowing\" the manager per se. Accessing the underlying MemorySegment. Note The lifecycle of a block is handled by a reference counter. When you allocate the block, the counter equals to 1. You can extend the lifetime of a block by calling AddRef(). But always call a corresponding Dispose() to release the hold you have on this block. If the reference counter was 1 before Dispose() is called, then the memory block will be deallocated and its corresponding memory area no longer usable. Memory Segment MemorySegment a struct that simply describes a linear segment of memory data, it's made of an address and a length. A MemoryBlock can be seen as a MemorySegment, but the reverse is not necessarily true. You can for instance split a segment in two, the second one won't be a valid MemoryBlock. You can convert a MemorySegment into a Span<T> and use the .net APIs relying on it for safe memory access. Note that while doing this you should ensure the lifetime of the underlying memory block is adequate. Default Memory Manager The implementation of DefaultMemoryManager was deliberately kept aside from being too complex, but still with the goal of achieving overall decent performances. You can have multiple instance of this type, but you are encourage to use the default one, accessible from the static property of its type. Tip Use the GlobalInstance static property of DefaultMemoryManager which is enough for most scenarios. Tip If you pass null to methods taking an IMemoryManager as parameter the GlobalInstance memory manager will be used. Memory Manager over a Memory Mapped File A memory mapped file (MMF for short) serves two purpose: Acts as a medium for interprocess communication, data exchange. Stores persistent data that can be consumed, processed directly through .net instances. The MemoryManagerOverMMF type allows to interact with a MMF through a Memory Manager."
  },
  "doc/murmurhash2.html": {
    "href": "doc/murmurhash2.html",
    "title": "| Tomate",
    "keywords": "The MurmurHash2 type implement the popular MurMur hashing algorithm. The implementation was ripped from here."
  },
  "doc/quickrand.html": {
    "href": "doc/quickrand.html",
    "title": "| Tomate",
    "keywords": "The QuickRand static class implements a simple random number generator. See the comment on stackoverflow."
  },
  "doc/string64.html": {
    "href": "doc/string64.html",
    "title": "| Tomate",
    "keywords": "The String64 type is a struct of 64 bytes, storing a string's content encoded with the UTF8 format."
  },
  "doc/synchronization.html": {
    "href": "doc/synchronization.html",
    "title": "Synchronization overview | Tomate",
    "keywords": "Synchronization overview Why? The OS and .NET offer many mechanisms to take care about synchronization between threads and processes. The traditional lock of .net implemented by the monitor class is doing a very good job but is general purpose. 🍅 implements custom types with specific features to allows very low latency synchronization between threads and/or processes. These types are also designed to take full advantage of multi-core CPU and very short locking span. AccessControl The AccessControl type allows processes/threads to control the usage of a particular resource. Multiple concurrent access are supported through the shared mode, one concurrent access is supported through the exclusive mode. This type is very small in size (8bytes) and is supported interprocess communication, that is, not only the thread is stored for synchronization but also the process id. BurnBabyBurn The BurnBabyBurn is a simple type that spins the calling thread for a given time span. It allows to attempt an operation for a given time span, until the operation succeed or the time span is reached. For instance the implementation the ExclusiveAccessControl.TakeControl() method. public bool TakeControl(TimeSpan? wait) { var tid = Environment.CurrentManagedThreadId; if (Interlocked.CompareExchange(ref _data, tid, 0) == 0) { return true; } var bbb = new BurnBabyBurn(wait); while (bbb.Wait()) { if (Interlocked.CompareExchange(ref _data, tid, 0) == 0) { return true; } } return false; } ExclusiveAccessControl The Tomate.ExclusiveAccessControl is a very lightweight access control type (4 bytes), that only works for the calling process (can't be stored in a Memory Mapped File) and supporting only an exclusive access. This type allows many threads to compete for the exclusive access of a given resource, avoiding concurrent usage. SmallLock The SmallLock implements an interprocess lock mechanism. By storing an instance of this type on a Memory Mapped File you can control the concurrent accesses of a given resource. At construction, the SmallLock's instance asks for a maximum concurrency level, this number can't be exceeding during usage. For instance if the level is 4 and you end up having more than 4 process/thread during concurrent operation at a given time, and exception will throw."
  },
  "index.html": {
    "href": "index.html",
    "title": "🍅 Tomate 🍅 | Tomate",
    "keywords": "🍅 Tomate 🍅 Low level library for concurrent, high performance, low GC impact data storing & manipulation. Also allowing interprocess communication and real-time processing of persistent data through a set of collections and primitives that operate over a Memory Mapped File. What it is about? .net standard libraries are great, especially the collection ones, they allow one to write code very quickly/easily. But if you are looking to squeeze performances or working on very low latency code, you can't afford to create thousand of GC objects anymore. Suddenly all the collection types you know and love as well as working with class types all the time is no longer an option. This library introduces a new way for the user to deal with memory and includes collections and other utility types that are compliant with it. The latest versions of C# and .net allow us to be closer to the metal, this library attempts to get you closer to it. What this library targets? Performance First Nowadays, computers are really fast, but it is very hard for many to realize how many things you can do with them. If the programmer doesn't pay attention to performances, the result can quickly get 10x to several 100x times slower. For many, performances is not an issue, so why paying attention to it if your code runs fast enough? And it's fine. But if performances is on the top of your list, you know that you have to design you code and develop with a \"performance first\" mindset. Low latency code If you are doing real-time programming for instance, you have to deal with a lot of things in just few milliseconds. Your territory is in the nanosecond or microsecond execution of your methods. You can't afford to spend you time allocating/releasing memory heaps, you have to pay attention to each data copy. Thread-safe, concurrent friendly code Because our computers have more and more CPU cores, we can't rely on single-threaded code anymore. But multi-threaded code is far from easy and it doesn't get easier when we are targeting low latency code. A mutex lock/unlock is about 100ns, a thread context switch is in the mater of millisecond, so we have to avoid them as much as possible. This library provides thread-safe types, but not exclusively (because single-threaded will always be faster) to help you and ease things. Operating over a Memory Mapped File Memory Mapped File (MMF for short) can be used in many scenarios: Interprocess communication : multiple process exchanges data by writing and reading in a given MMF. Streaming of very large data : a persistent MMF can store hundreds of gigabytes and be virtually completely accessible from memory. 🍅 implements a set of collections and features for you to structure the data stored in an MMF and taking care of multi-thread, interprocess synchronization."
  }
}